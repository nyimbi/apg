# Generated from /Volumes/Media/src/pjs/appgen/lang/appgen.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,202,1126,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        1,0,1,0,1,1,1,1,1,2,1,2,1,3,1,3,1,4,1,4,1,5,1,5,1,6,1,6,1,6,5,6,
        246,8,6,10,6,12,6,249,9,6,1,6,3,6,252,8,6,1,7,1,7,1,7,5,7,257,8,
        7,10,7,12,7,260,9,7,1,7,3,7,263,8,7,1,8,1,8,1,8,5,8,268,8,8,10,8,
        12,8,271,9,8,1,8,3,8,274,8,8,1,9,1,9,3,9,278,8,9,1,9,1,9,1,9,1,9,
        1,9,1,9,1,9,3,9,287,8,9,1,10,1,10,1,10,5,10,292,8,10,10,10,12,10,
        295,9,10,1,10,3,10,298,8,10,1,11,3,11,301,8,11,1,11,3,11,304,8,11,
        1,11,4,11,307,8,11,11,11,12,11,308,1,11,1,11,1,12,1,12,1,12,1,12,
        3,12,317,8,12,1,13,1,13,3,13,321,8,13,1,13,5,13,324,8,13,10,13,12,
        13,327,9,13,1,14,1,14,1,15,1,15,1,15,1,15,1,15,1,15,1,16,1,16,1,
        17,1,17,1,17,5,17,342,8,17,10,17,12,17,345,9,17,1,17,3,17,348,8,
        17,1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,357,8,18,1,18,1,18,1,
        18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,372,8,
        18,1,19,1,19,1,19,1,19,4,19,378,8,19,11,19,12,19,379,1,19,1,19,1,
        20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,392,8,20,3,20,394,8,20,
        1,20,3,20,397,8,20,1,21,1,21,1,21,1,21,1,22,1,22,1,22,1,22,1,22,
        1,22,3,22,409,8,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,1,25,
        1,25,1,25,1,25,1,26,1,26,1,26,1,26,1,27,1,27,1,28,1,28,1,28,1,28,
        5,28,433,8,28,10,28,12,28,436,9,28,1,28,3,28,439,8,28,1,28,1,28,
        1,28,1,28,3,28,445,8,28,1,29,1,29,1,30,1,30,1,30,1,30,1,31,1,31,
        1,32,1,32,1,32,1,32,5,32,459,8,32,10,32,12,32,462,9,32,1,32,3,32,
        465,8,32,1,32,1,32,1,32,1,32,3,32,471,8,32,1,33,1,33,1,34,1,34,1,
        34,1,34,1,35,1,35,1,35,1,35,5,35,483,8,35,10,35,12,35,486,9,35,1,
        35,3,35,489,8,35,1,35,1,35,1,35,1,35,3,35,495,8,35,1,36,1,36,1,37,
        1,37,1,37,1,37,1,37,3,37,504,8,37,1,38,1,38,1,38,1,38,1,39,1,39,
        1,40,1,40,1,40,1,40,1,40,1,40,3,40,518,8,40,1,41,1,41,1,42,1,42,
        3,42,524,8,42,1,43,1,43,1,43,1,43,1,44,1,44,1,45,1,45,1,45,1,45,
        5,45,536,8,45,10,45,12,45,539,9,45,1,45,3,45,542,8,45,1,45,1,45,
        1,45,1,45,3,45,548,8,45,1,46,1,46,1,46,3,46,553,8,46,1,47,1,47,1,
        48,1,48,1,48,1,48,5,48,561,8,48,10,48,12,48,564,9,48,1,48,3,48,567,
        8,48,1,48,1,48,1,49,1,49,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,
        3,50,581,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,
        1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,
        3,50,606,8,50,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,3,52,672,8,52,1,53,1,53,1,53,3,53,677,8,53,1,53,1,53,1,
        54,1,54,1,54,3,54,684,8,54,1,54,1,54,1,55,1,55,1,55,1,55,1,55,1,
        55,1,55,1,55,1,55,3,55,697,8,55,1,56,1,56,1,57,1,57,1,57,1,57,1,
        57,1,57,1,58,1,58,1,58,1,58,1,58,1,58,1,59,1,59,1,59,5,59,716,8,
        59,10,59,12,59,719,9,59,1,59,3,59,722,8,59,1,60,1,60,1,60,3,60,727,
        8,60,1,60,1,60,1,60,1,60,1,60,3,60,734,8,60,1,61,1,61,1,62,1,62,
        1,63,1,63,1,63,1,63,1,64,1,64,1,64,1,64,1,65,1,65,1,66,1,66,1,66,
        1,66,1,66,1,67,1,67,1,67,1,67,1,67,1,67,3,67,761,8,67,1,67,1,67,
        1,67,3,67,766,8,67,1,67,3,67,769,8,67,1,67,1,67,1,68,3,68,774,8,
        68,1,68,1,68,5,68,778,8,68,10,68,12,68,781,9,68,1,69,1,69,1,70,1,
        70,1,70,1,70,1,70,1,70,1,71,1,71,1,71,1,71,1,72,1,72,3,72,797,8,
        72,1,72,1,72,1,72,1,72,1,72,3,72,804,8,72,1,72,1,72,1,72,1,72,1,
        73,1,73,3,73,812,8,73,1,73,1,73,1,73,1,73,3,73,818,8,73,1,73,1,73,
        1,73,4,73,823,8,73,11,73,12,73,824,1,73,1,73,1,73,1,73,4,73,831,
        8,73,11,73,12,73,832,1,74,1,74,1,75,1,75,1,75,1,75,3,75,841,8,75,
        1,76,1,76,1,77,1,77,1,78,1,78,1,79,1,79,1,80,1,80,3,80,853,8,80,
        1,80,1,80,1,80,1,80,1,80,1,80,1,80,3,80,862,8,80,1,81,1,81,1,81,
        1,81,1,81,1,81,1,82,1,82,1,82,5,82,873,8,82,10,82,12,82,876,9,82,
        1,83,1,83,1,83,3,83,881,8,83,1,83,1,83,1,83,1,83,1,83,3,83,888,8,
        83,1,84,1,84,1,84,5,84,893,8,84,10,84,12,84,896,9,84,1,84,3,84,899,
        8,84,1,85,1,85,1,86,1,86,1,86,1,86,1,86,1,86,1,87,1,87,1,87,1,87,
        1,88,1,88,1,88,1,88,1,88,1,88,1,89,1,89,1,90,1,90,1,90,1,90,1,90,
        1,90,1,90,1,90,1,90,1,90,1,90,1,90,3,90,933,8,90,1,91,1,91,1,91,
        1,91,1,91,1,92,1,92,1,92,1,92,1,93,1,93,1,93,1,93,1,93,1,93,1,93,
        1,93,1,93,3,93,953,8,93,1,94,1,94,1,95,1,95,1,95,1,95,1,95,1,95,
        1,95,1,95,1,95,1,95,1,95,1,95,1,95,1,95,3,95,971,8,95,1,96,1,96,
        1,96,1,96,1,96,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,98,1,98,1,98,
        1,98,1,98,1,99,1,99,1,99,1,99,1,99,1,100,1,100,1,100,1,100,1,100,
        1,101,1,101,1,101,1,101,1,101,1,101,1,101,1,102,1,102,1,102,1,102,
        1,102,1,102,1,102,1,103,1,103,1,103,1,103,1,103,1,104,1,104,1,105,
        1,105,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,
        1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,
        1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,
        1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,
        1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,
        3,106,1077,8,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,1,106,
        1,106,1,106,1,106,1,106,1,106,1,106,5,106,1093,8,106,10,106,12,106,
        1096,9,106,1,107,1,107,1,107,5,107,1101,8,107,10,107,12,107,1104,
        9,107,1,107,3,107,1107,8,107,1,108,1,108,1,109,1,109,1,110,1,110,
        1,111,1,111,1,112,1,112,1,112,3,112,1120,8,112,1,113,1,113,1,114,
        1,114,1,114,0,1,212,115,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
        30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
        74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,
        114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,
        146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,
        178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,
        210,212,214,216,218,220,222,224,226,228,0,13,1,0,191,195,1,0,183,
        183,1,0,59,62,1,0,65,69,1,0,70,71,1,0,72,73,2,0,57,57,76,76,1,0,
        116,117,1,0,114,115,2,0,131,132,134,136,1,0,124,125,3,0,106,106,
        118,119,121,123,1,0,114,117,1220,0,230,1,0,0,0,2,232,1,0,0,0,4,234,
        1,0,0,0,6,236,1,0,0,0,8,238,1,0,0,0,10,240,1,0,0,0,12,242,1,0,0,
        0,14,253,1,0,0,0,16,264,1,0,0,0,18,277,1,0,0,0,20,288,1,0,0,0,22,
        300,1,0,0,0,24,316,1,0,0,0,26,318,1,0,0,0,28,328,1,0,0,0,30,330,
        1,0,0,0,32,336,1,0,0,0,34,338,1,0,0,0,36,371,1,0,0,0,38,373,1,0,
        0,0,40,396,1,0,0,0,42,398,1,0,0,0,44,408,1,0,0,0,46,410,1,0,0,0,
        48,414,1,0,0,0,50,418,1,0,0,0,52,422,1,0,0,0,54,426,1,0,0,0,56,444,
        1,0,0,0,58,446,1,0,0,0,60,448,1,0,0,0,62,452,1,0,0,0,64,470,1,0,
        0,0,66,472,1,0,0,0,68,474,1,0,0,0,70,494,1,0,0,0,72,496,1,0,0,0,
        74,503,1,0,0,0,76,505,1,0,0,0,78,509,1,0,0,0,80,517,1,0,0,0,82,519,
        1,0,0,0,84,523,1,0,0,0,86,525,1,0,0,0,88,529,1,0,0,0,90,547,1,0,
        0,0,92,549,1,0,0,0,94,554,1,0,0,0,96,556,1,0,0,0,98,570,1,0,0,0,
        100,605,1,0,0,0,102,607,1,0,0,0,104,671,1,0,0,0,106,676,1,0,0,0,
        108,683,1,0,0,0,110,696,1,0,0,0,112,698,1,0,0,0,114,700,1,0,0,0,
        116,706,1,0,0,0,118,712,1,0,0,0,120,726,1,0,0,0,122,735,1,0,0,0,
        124,737,1,0,0,0,126,739,1,0,0,0,128,743,1,0,0,0,130,747,1,0,0,0,
        132,749,1,0,0,0,134,754,1,0,0,0,136,773,1,0,0,0,138,782,1,0,0,0,
        140,784,1,0,0,0,142,790,1,0,0,0,144,794,1,0,0,0,146,809,1,0,0,0,
        148,834,1,0,0,0,150,840,1,0,0,0,152,842,1,0,0,0,154,844,1,0,0,0,
        156,846,1,0,0,0,158,848,1,0,0,0,160,850,1,0,0,0,162,863,1,0,0,0,
        164,869,1,0,0,0,166,880,1,0,0,0,168,889,1,0,0,0,170,900,1,0,0,0,
        172,902,1,0,0,0,174,908,1,0,0,0,176,912,1,0,0,0,178,918,1,0,0,0,
        180,932,1,0,0,0,182,934,1,0,0,0,184,939,1,0,0,0,186,943,1,0,0,0,
        188,954,1,0,0,0,190,956,1,0,0,0,192,972,1,0,0,0,194,977,1,0,0,0,
        196,984,1,0,0,0,198,989,1,0,0,0,200,994,1,0,0,0,202,999,1,0,0,0,
        204,1006,1,0,0,0,206,1013,1,0,0,0,208,1018,1,0,0,0,210,1020,1,0,
        0,0,212,1076,1,0,0,0,214,1097,1,0,0,0,216,1108,1,0,0,0,218,1110,
        1,0,0,0,220,1112,1,0,0,0,222,1114,1,0,0,0,224,1116,1,0,0,0,226,1121,
        1,0,0,0,228,1123,1,0,0,0,230,231,5,153,0,0,231,1,1,0,0,0,232,233,
        7,0,0,0,233,3,1,0,0,0,234,235,5,132,0,0,235,5,1,0,0,0,236,237,5,
        131,0,0,237,7,1,0,0,0,238,239,5,130,0,0,239,9,1,0,0,0,240,241,3,
        8,4,0,241,11,1,0,0,0,242,247,3,4,2,0,243,244,5,103,0,0,244,246,3,
        4,2,0,245,243,1,0,0,0,246,249,1,0,0,0,247,245,1,0,0,0,247,248,1,
        0,0,0,248,251,1,0,0,0,249,247,1,0,0,0,250,252,5,103,0,0,251,250,
        1,0,0,0,251,252,1,0,0,0,252,13,1,0,0,0,253,258,3,8,4,0,254,255,5,
        103,0,0,255,257,3,8,4,0,256,254,1,0,0,0,257,260,1,0,0,0,258,256,
        1,0,0,0,258,259,1,0,0,0,259,262,1,0,0,0,260,258,1,0,0,0,261,263,
        5,103,0,0,262,261,1,0,0,0,262,263,1,0,0,0,263,15,1,0,0,0,264,269,
        3,6,3,0,265,266,5,103,0,0,266,268,3,6,3,0,267,265,1,0,0,0,268,271,
        1,0,0,0,269,267,1,0,0,0,269,270,1,0,0,0,270,273,1,0,0,0,271,269,
        1,0,0,0,272,274,5,103,0,0,273,272,1,0,0,0,273,274,1,0,0,0,274,17,
        1,0,0,0,275,278,3,8,4,0,276,278,3,6,3,0,277,275,1,0,0,0,277,276,
        1,0,0,0,278,279,1,0,0,0,279,286,5,106,0,0,280,287,3,6,3,0,281,287,
        3,16,8,0,282,287,3,8,4,0,283,287,3,14,7,0,284,287,3,12,6,0,285,287,
        3,4,2,0,286,280,1,0,0,0,286,281,1,0,0,0,286,282,1,0,0,0,286,283,
        1,0,0,0,286,284,1,0,0,0,286,285,1,0,0,0,287,19,1,0,0,0,288,293,3,
        18,9,0,289,290,5,103,0,0,290,292,3,18,9,0,291,289,1,0,0,0,292,295,
        1,0,0,0,293,291,1,0,0,0,293,294,1,0,0,0,294,297,1,0,0,0,295,293,
        1,0,0,0,296,298,5,103,0,0,297,296,1,0,0,0,297,298,1,0,0,0,298,21,
        1,0,0,0,299,301,3,24,12,0,300,299,1,0,0,0,300,301,1,0,0,0,301,303,
        1,0,0,0,302,304,3,30,15,0,303,302,1,0,0,0,303,304,1,0,0,0,304,306,
        1,0,0,0,305,307,3,74,37,0,306,305,1,0,0,0,307,308,1,0,0,0,308,306,
        1,0,0,0,308,309,1,0,0,0,309,310,1,0,0,0,310,311,5,0,0,1,311,23,1,
        0,0,0,312,313,5,148,0,0,313,317,3,26,13,0,314,315,5,149,0,0,315,
        317,3,26,13,0,316,312,1,0,0,0,316,314,1,0,0,0,317,25,1,0,0,0,318,
        325,3,28,14,0,319,321,5,103,0,0,320,319,1,0,0,0,320,321,1,0,0,0,
        321,322,1,0,0,0,322,324,3,28,14,0,323,320,1,0,0,0,324,327,1,0,0,
        0,325,323,1,0,0,0,325,326,1,0,0,0,326,27,1,0,0,0,327,325,1,0,0,0,
        328,329,3,8,4,0,329,29,1,0,0,0,330,331,5,156,0,0,331,332,3,32,16,
        0,332,333,5,111,0,0,333,334,3,34,17,0,334,335,5,112,0,0,335,31,1,
        0,0,0,336,337,3,10,5,0,337,33,1,0,0,0,338,343,3,36,18,0,339,340,
        5,103,0,0,340,342,3,36,18,0,341,339,1,0,0,0,342,345,1,0,0,0,343,
        341,1,0,0,0,343,344,1,0,0,0,344,347,1,0,0,0,345,343,1,0,0,0,346,
        348,5,103,0,0,347,346,1,0,0,0,347,348,1,0,0,0,348,35,1,0,0,0,349,
        350,5,1,0,0,350,351,5,106,0,0,351,372,3,6,3,0,352,353,5,151,0,0,
        353,356,5,106,0,0,354,357,3,6,3,0,355,357,5,142,0,0,356,354,1,0,
        0,0,356,355,1,0,0,0,357,372,1,0,0,0,358,359,5,201,0,0,359,360,5,
        106,0,0,360,372,3,6,3,0,361,362,5,202,0,0,362,363,5,106,0,0,363,
        372,3,6,3,0,364,372,3,68,34,0,365,372,3,42,21,0,366,372,3,46,23,
        0,367,372,3,52,26,0,368,372,3,50,25,0,369,372,3,38,19,0,370,372,
        3,18,9,0,371,349,1,0,0,0,371,352,1,0,0,0,371,358,1,0,0,0,371,361,
        1,0,0,0,371,364,1,0,0,0,371,365,1,0,0,0,371,366,1,0,0,0,371,367,
        1,0,0,0,371,368,1,0,0,0,371,369,1,0,0,0,371,370,1,0,0,0,372,37,1,
        0,0,0,373,374,5,170,0,0,374,375,5,106,0,0,375,377,5,109,0,0,376,
        378,3,40,20,0,377,376,1,0,0,0,378,379,1,0,0,0,379,377,1,0,0,0,379,
        380,1,0,0,0,380,381,1,0,0,0,381,382,5,110,0,0,382,39,1,0,0,0,383,
        397,5,185,0,0,384,397,5,186,0,0,385,397,5,188,0,0,386,397,5,190,
        0,0,387,393,5,187,0,0,388,391,5,152,0,0,389,392,3,2,1,0,390,392,
        3,6,3,0,391,389,1,0,0,0,391,390,1,0,0,0,392,394,1,0,0,0,393,388,
        1,0,0,0,393,394,1,0,0,0,394,397,1,0,0,0,395,397,3,6,3,0,396,383,
        1,0,0,0,396,384,1,0,0,0,396,385,1,0,0,0,396,386,1,0,0,0,396,387,
        1,0,0,0,396,395,1,0,0,0,397,41,1,0,0,0,398,399,5,171,0,0,399,400,
        5,106,0,0,400,401,3,44,22,0,401,43,1,0,0,0,402,403,5,109,0,0,403,
        404,3,20,10,0,404,405,5,110,0,0,405,409,1,0,0,0,406,407,5,109,0,
        0,407,409,5,110,0,0,408,402,1,0,0,0,408,406,1,0,0,0,409,45,1,0,0,
        0,410,411,5,172,0,0,411,412,5,106,0,0,412,413,3,48,24,0,413,47,1,
        0,0,0,414,415,5,109,0,0,415,416,3,16,8,0,416,417,5,110,0,0,417,49,
        1,0,0,0,418,419,5,173,0,0,419,420,5,106,0,0,420,421,3,6,3,0,421,
        51,1,0,0,0,422,423,5,165,0,0,423,424,3,54,27,0,424,425,3,56,28,0,
        425,53,1,0,0,0,426,427,3,10,5,0,427,55,1,0,0,0,428,429,5,111,0,0,
        429,434,3,58,29,0,430,431,5,103,0,0,431,433,3,58,29,0,432,430,1,
        0,0,0,433,436,1,0,0,0,434,432,1,0,0,0,434,435,1,0,0,0,435,438,1,
        0,0,0,436,434,1,0,0,0,437,439,5,103,0,0,438,437,1,0,0,0,438,439,
        1,0,0,0,439,440,1,0,0,0,440,441,5,112,0,0,441,445,1,0,0,0,442,443,
        5,111,0,0,443,445,5,112,0,0,444,428,1,0,0,0,444,442,1,0,0,0,445,
        57,1,0,0,0,446,447,3,18,9,0,447,59,1,0,0,0,448,449,5,175,0,0,449,
        450,3,62,31,0,450,451,3,64,32,0,451,61,1,0,0,0,452,453,3,10,5,0,
        453,63,1,0,0,0,454,455,5,111,0,0,455,460,3,66,33,0,456,457,5,103,
        0,0,457,459,3,66,33,0,458,456,1,0,0,0,459,462,1,0,0,0,460,458,1,
        0,0,0,460,461,1,0,0,0,461,464,1,0,0,0,462,460,1,0,0,0,463,465,5,
        103,0,0,464,463,1,0,0,0,464,465,1,0,0,0,465,466,1,0,0,0,466,467,
        5,112,0,0,467,471,1,0,0,0,468,469,5,111,0,0,469,471,5,112,0,0,470,
        454,1,0,0,0,470,468,1,0,0,0,471,65,1,0,0,0,472,473,3,18,9,0,473,
        67,1,0,0,0,474,475,5,169,0,0,475,476,5,106,0,0,476,477,3,70,35,0,
        477,69,1,0,0,0,478,479,5,111,0,0,479,484,3,72,36,0,480,481,5,103,
        0,0,481,483,3,72,36,0,482,480,1,0,0,0,483,486,1,0,0,0,484,482,1,
        0,0,0,484,485,1,0,0,0,485,488,1,0,0,0,486,484,1,0,0,0,487,489,5,
        103,0,0,488,487,1,0,0,0,488,489,1,0,0,0,489,490,1,0,0,0,490,491,
        5,112,0,0,491,495,1,0,0,0,492,493,5,111,0,0,493,495,5,112,0,0,494,
        478,1,0,0,0,494,492,1,0,0,0,495,71,1,0,0,0,496,497,3,18,9,0,497,
        73,1,0,0,0,498,504,3,80,40,0,499,504,3,146,73,0,500,504,3,116,58,
        0,501,504,3,160,80,0,502,504,3,182,91,0,503,498,1,0,0,0,503,499,
        1,0,0,0,503,500,1,0,0,0,503,501,1,0,0,0,503,502,1,0,0,0,504,75,1,
        0,0,0,505,506,5,168,0,0,506,507,3,78,39,0,507,508,3,6,3,0,508,77,
        1,0,0,0,509,510,3,10,5,0,510,79,1,0,0,0,511,518,3,82,41,0,512,518,
        3,84,42,0,513,518,3,134,67,0,514,518,3,86,43,0,515,518,3,140,70,
        0,516,518,3,76,38,0,517,511,1,0,0,0,517,512,1,0,0,0,517,513,1,0,
        0,0,517,514,1,0,0,0,517,515,1,0,0,0,517,516,1,0,0,0,518,81,1,0,0,
        0,519,520,3,10,5,0,520,83,1,0,0,0,521,524,5,182,0,0,522,524,3,8,
        4,0,523,521,1,0,0,0,523,522,1,0,0,0,524,85,1,0,0,0,525,526,5,163,
        0,0,526,527,3,88,44,0,527,528,3,90,45,0,528,87,1,0,0,0,529,530,3,
        10,5,0,530,89,1,0,0,0,531,532,5,111,0,0,532,537,3,92,46,0,533,534,
        5,103,0,0,534,536,3,92,46,0,535,533,1,0,0,0,536,539,1,0,0,0,537,
        535,1,0,0,0,537,538,1,0,0,0,538,541,1,0,0,0,539,537,1,0,0,0,540,
        542,5,103,0,0,541,540,1,0,0,0,541,542,1,0,0,0,542,543,1,0,0,0,543,
        544,5,112,0,0,544,548,1,0,0,0,545,546,5,111,0,0,546,548,5,112,0,
        0,547,531,1,0,0,0,547,545,1,0,0,0,548,91,1,0,0,0,549,550,3,94,47,
        0,550,552,3,104,52,0,551,553,3,96,48,0,552,551,1,0,0,0,552,553,1,
        0,0,0,553,93,1,0,0,0,554,555,3,10,5,0,555,95,1,0,0,0,556,557,5,109,
        0,0,557,562,3,100,50,0,558,559,5,103,0,0,559,561,3,100,50,0,560,
        558,1,0,0,0,561,564,1,0,0,0,562,560,1,0,0,0,562,563,1,0,0,0,563,
        566,1,0,0,0,564,562,1,0,0,0,565,567,5,103,0,0,566,565,1,0,0,0,566,
        567,1,0,0,0,567,568,1,0,0,0,568,569,5,110,0,0,569,97,1,0,0,0,570,
        571,7,1,0,0,571,99,1,0,0,0,572,606,3,98,49,0,573,574,5,178,0,0,574,
        575,5,106,0,0,575,606,3,110,55,0,576,580,5,154,0,0,577,578,5,107,
        0,0,578,579,5,132,0,0,579,581,5,108,0,0,580,577,1,0,0,0,580,581,
        1,0,0,0,581,606,1,0,0,0,582,583,5,179,0,0,583,584,5,106,0,0,584,
        585,5,107,0,0,585,586,3,6,3,0,586,587,5,108,0,0,587,606,1,0,0,0,
        588,606,5,144,0,0,589,606,5,145,0,0,590,606,3,0,0,0,591,606,5,196,
        0,0,592,606,5,146,0,0,593,606,3,144,72,0,594,606,3,114,57,0,595,
        596,5,176,0,0,596,597,5,106,0,0,597,606,5,132,0,0,598,599,5,177,
        0,0,599,600,5,106,0,0,600,606,5,132,0,0,601,602,5,155,0,0,602,606,
        3,102,51,0,603,606,3,126,63,0,604,606,3,128,64,0,605,572,1,0,0,0,
        605,573,1,0,0,0,605,576,1,0,0,0,605,582,1,0,0,0,605,588,1,0,0,0,
        605,589,1,0,0,0,605,590,1,0,0,0,605,591,1,0,0,0,605,592,1,0,0,0,
        605,593,1,0,0,0,605,594,1,0,0,0,605,595,1,0,0,0,605,598,1,0,0,0,
        605,601,1,0,0,0,605,603,1,0,0,0,605,604,1,0,0,0,606,101,1,0,0,0,
        607,608,5,107,0,0,608,609,3,6,3,0,609,610,5,108,0,0,610,103,1,0,
        0,0,611,672,5,2,0,0,612,672,5,3,0,0,613,672,5,4,0,0,614,672,5,5,
        0,0,615,672,5,6,0,0,616,672,5,7,0,0,617,672,5,8,0,0,618,672,5,9,
        0,0,619,672,5,10,0,0,620,672,5,11,0,0,621,672,5,12,0,0,622,672,5,
        13,0,0,623,672,5,14,0,0,624,672,5,15,0,0,625,672,3,132,66,0,626,
        672,5,16,0,0,627,672,5,17,0,0,628,672,5,18,0,0,629,672,5,19,0,0,
        630,672,5,20,0,0,631,672,5,21,0,0,632,672,5,180,0,0,633,672,5,22,
        0,0,634,672,5,23,0,0,635,672,5,24,0,0,636,672,5,25,0,0,637,672,5,
        26,0,0,638,672,5,27,0,0,639,672,5,28,0,0,640,672,5,29,0,0,641,672,
        5,30,0,0,642,672,5,31,0,0,643,672,5,32,0,0,644,672,5,33,0,0,645,
        672,5,34,0,0,646,672,5,35,0,0,647,672,5,36,0,0,648,672,5,37,0,0,
        649,672,5,38,0,0,650,672,5,39,0,0,651,672,5,40,0,0,652,672,5,41,
        0,0,653,672,5,42,0,0,654,672,5,43,0,0,655,672,5,44,0,0,656,672,5,
        45,0,0,657,672,5,46,0,0,658,672,5,47,0,0,659,672,5,48,0,0,660,672,
        1,0,0,0,661,672,5,181,0,0,662,672,5,49,0,0,663,672,5,50,0,0,664,
        672,5,51,0,0,665,672,3,112,56,0,666,667,5,52,0,0,667,668,3,12,6,
        0,668,669,5,53,0,0,669,670,3,104,52,0,670,672,1,0,0,0,671,611,1,
        0,0,0,671,612,1,0,0,0,671,613,1,0,0,0,671,614,1,0,0,0,671,615,1,
        0,0,0,671,616,1,0,0,0,671,617,1,0,0,0,671,618,1,0,0,0,671,619,1,
        0,0,0,671,620,1,0,0,0,671,621,1,0,0,0,671,622,1,0,0,0,671,623,1,
        0,0,0,671,624,1,0,0,0,671,625,1,0,0,0,671,626,1,0,0,0,671,627,1,
        0,0,0,671,628,1,0,0,0,671,629,1,0,0,0,671,630,1,0,0,0,671,631,1,
        0,0,0,671,632,1,0,0,0,671,633,1,0,0,0,671,634,1,0,0,0,671,635,1,
        0,0,0,671,636,1,0,0,0,671,637,1,0,0,0,671,638,1,0,0,0,671,639,1,
        0,0,0,671,640,1,0,0,0,671,641,1,0,0,0,671,642,1,0,0,0,671,643,1,
        0,0,0,671,644,1,0,0,0,671,645,1,0,0,0,671,646,1,0,0,0,671,647,1,
        0,0,0,671,648,1,0,0,0,671,649,1,0,0,0,671,650,1,0,0,0,671,651,1,
        0,0,0,671,652,1,0,0,0,671,653,1,0,0,0,671,654,1,0,0,0,671,655,1,
        0,0,0,671,656,1,0,0,0,671,657,1,0,0,0,671,658,1,0,0,0,671,659,1,
        0,0,0,671,660,1,0,0,0,671,661,1,0,0,0,671,662,1,0,0,0,671,663,1,
        0,0,0,671,664,1,0,0,0,671,665,1,0,0,0,671,666,1,0,0,0,672,105,1,
        0,0,0,673,674,3,108,54,0,674,675,5,113,0,0,675,677,1,0,0,0,676,673,
        1,0,0,0,676,677,1,0,0,0,677,678,1,0,0,0,678,679,3,94,47,0,679,107,
        1,0,0,0,680,681,3,84,42,0,681,682,5,113,0,0,682,684,1,0,0,0,683,
        680,1,0,0,0,683,684,1,0,0,0,684,685,1,0,0,0,685,686,3,138,69,0,686,
        109,1,0,0,0,687,697,5,133,0,0,688,697,3,6,3,0,689,697,5,137,0,0,
        690,697,5,197,0,0,691,697,5,198,0,0,692,697,5,200,0,0,693,697,5,
        54,0,0,694,697,5,55,0,0,695,697,5,147,0,0,696,687,1,0,0,0,696,688,
        1,0,0,0,696,689,1,0,0,0,696,690,1,0,0,0,696,691,1,0,0,0,696,692,
        1,0,0,0,696,693,1,0,0,0,696,694,1,0,0,0,696,695,1,0,0,0,697,111,
        1,0,0,0,698,699,3,10,5,0,699,113,1,0,0,0,700,701,5,174,0,0,701,702,
        5,106,0,0,702,703,5,111,0,0,703,704,3,118,59,0,704,705,5,112,0,0,
        705,115,1,0,0,0,706,707,5,174,0,0,707,708,3,112,56,0,708,709,5,111,
        0,0,709,710,3,118,59,0,710,711,5,112,0,0,711,117,1,0,0,0,712,717,
        3,120,60,0,713,714,5,103,0,0,714,716,3,120,60,0,715,713,1,0,0,0,
        716,719,1,0,0,0,717,715,1,0,0,0,717,718,1,0,0,0,718,721,1,0,0,0,
        719,717,1,0,0,0,720,722,5,103,0,0,721,720,1,0,0,0,721,722,1,0,0,
        0,722,119,1,0,0,0,723,724,3,122,61,0,724,725,5,106,0,0,725,727,1,
        0,0,0,726,723,1,0,0,0,726,727,1,0,0,0,727,728,1,0,0,0,728,733,3,
        124,62,0,729,730,5,109,0,0,730,731,3,128,64,0,731,732,5,110,0,0,
        732,734,1,0,0,0,733,729,1,0,0,0,733,734,1,0,0,0,734,121,1,0,0,0,
        735,736,3,4,2,0,736,123,1,0,0,0,737,738,3,6,3,0,738,125,1,0,0,0,
        739,740,5,150,0,0,740,741,5,106,0,0,741,742,3,20,10,0,742,127,1,
        0,0,0,743,744,5,159,0,0,744,745,5,106,0,0,745,746,3,130,65,0,746,
        129,1,0,0,0,747,748,3,6,3,0,748,131,1,0,0,0,749,750,5,158,0,0,750,
        751,5,107,0,0,751,752,5,132,0,0,752,753,5,108,0,0,753,133,1,0,0,
        0,754,755,5,162,0,0,755,760,3,138,69,0,756,757,5,107,0,0,757,758,
        3,136,68,0,758,759,5,108,0,0,759,761,1,0,0,0,760,756,1,0,0,0,760,
        761,1,0,0,0,761,762,1,0,0,0,762,763,5,111,0,0,763,765,3,90,45,0,
        764,766,3,162,81,0,765,764,1,0,0,0,765,766,1,0,0,0,766,768,1,0,0,
        0,767,769,3,172,86,0,768,767,1,0,0,0,768,769,1,0,0,0,769,770,1,0,
        0,0,770,771,5,112,0,0,771,135,1,0,0,0,772,774,3,88,44,0,773,772,
        1,0,0,0,773,774,1,0,0,0,774,779,1,0,0,0,775,776,5,103,0,0,776,778,
        3,88,44,0,777,775,1,0,0,0,778,781,1,0,0,0,779,777,1,0,0,0,779,780,
        1,0,0,0,780,137,1,0,0,0,781,779,1,0,0,0,782,783,3,10,5,0,783,139,
        1,0,0,0,784,785,5,167,0,0,785,786,5,106,0,0,786,787,5,107,0,0,787,
        788,3,142,71,0,788,789,5,108,0,0,789,141,1,0,0,0,790,791,3,106,53,
        0,791,792,5,106,0,0,792,793,3,106,53,0,793,143,1,0,0,0,794,796,5,
        161,0,0,795,797,3,148,74,0,796,795,1,0,0,0,796,797,1,0,0,0,797,798,
        1,0,0,0,798,799,5,104,0,0,799,803,3,150,75,0,800,801,3,84,42,0,801,
        802,5,113,0,0,802,804,1,0,0,0,803,800,1,0,0,0,803,804,1,0,0,0,804,
        805,1,0,0,0,805,806,3,138,69,0,806,807,5,113,0,0,807,808,3,94,47,
        0,808,145,1,0,0,0,809,811,5,161,0,0,810,812,3,148,74,0,811,810,1,
        0,0,0,811,812,1,0,0,0,812,813,1,0,0,0,813,817,5,104,0,0,814,815,
        3,84,42,0,815,816,5,113,0,0,816,818,1,0,0,0,817,814,1,0,0,0,817,
        818,1,0,0,0,818,819,1,0,0,0,819,820,3,138,69,0,820,822,5,113,0,0,
        821,823,3,94,47,0,822,821,1,0,0,0,823,824,1,0,0,0,824,822,1,0,0,
        0,824,825,1,0,0,0,825,826,1,0,0,0,826,827,3,150,75,0,827,828,3,138,
        69,0,828,830,5,113,0,0,829,831,3,94,47,0,830,829,1,0,0,0,831,832,
        1,0,0,0,832,830,1,0,0,0,832,833,1,0,0,0,833,147,1,0,0,0,834,835,
        3,10,5,0,835,149,1,0,0,0,836,841,3,152,76,0,837,841,3,154,77,0,838,
        841,3,156,78,0,839,841,3,158,79,0,840,836,1,0,0,0,840,837,1,0,0,
        0,840,838,1,0,0,0,840,839,1,0,0,0,841,151,1,0,0,0,842,843,5,115,
        0,0,843,153,1,0,0,0,844,845,5,118,0,0,845,155,1,0,0,0,846,847,5,
        119,0,0,847,157,1,0,0,0,848,849,5,120,0,0,849,159,1,0,0,0,850,852,
        5,56,0,0,851,853,3,170,85,0,852,851,1,0,0,0,852,853,1,0,0,0,853,
        854,1,0,0,0,854,855,5,57,0,0,855,856,3,138,69,0,856,857,5,109,0,
        0,857,858,3,168,84,0,858,861,5,110,0,0,859,860,5,58,0,0,860,862,
        7,2,0,0,861,859,1,0,0,0,861,862,1,0,0,0,862,161,1,0,0,0,863,864,
        5,63,0,0,864,865,5,106,0,0,865,866,5,111,0,0,866,867,3,164,82,0,
        867,868,5,112,0,0,868,163,1,0,0,0,869,874,3,166,83,0,870,871,5,103,
        0,0,871,873,3,166,83,0,872,870,1,0,0,0,873,876,1,0,0,0,874,872,1,
        0,0,0,874,875,1,0,0,0,875,165,1,0,0,0,876,874,1,0,0,0,877,878,3,
        170,85,0,878,879,5,106,0,0,879,881,1,0,0,0,880,877,1,0,0,0,880,881,
        1,0,0,0,881,882,1,0,0,0,882,883,5,109,0,0,883,884,3,168,84,0,884,
        887,5,110,0,0,885,886,5,58,0,0,886,888,7,2,0,0,887,885,1,0,0,0,887,
        888,1,0,0,0,888,167,1,0,0,0,889,894,3,94,47,0,890,891,5,103,0,0,
        891,893,3,94,47,0,892,890,1,0,0,0,893,896,1,0,0,0,894,892,1,0,0,
        0,894,895,1,0,0,0,895,898,1,0,0,0,896,894,1,0,0,0,897,899,5,103,
        0,0,898,897,1,0,0,0,898,899,1,0,0,0,899,169,1,0,0,0,900,901,3,10,
        5,0,901,171,1,0,0,0,902,903,5,64,0,0,903,904,5,106,0,0,904,905,5,
        111,0,0,905,906,3,174,87,0,906,907,5,112,0,0,907,173,1,0,0,0,908,
        909,3,176,88,0,909,910,5,103,0,0,910,911,3,176,88,0,911,175,1,0,
        0,0,912,913,3,178,89,0,913,914,5,104,0,0,914,915,5,111,0,0,915,916,
        3,180,90,0,916,917,5,112,0,0,917,177,1,0,0,0,918,919,7,3,0,0,919,
        179,1,0,0,0,920,921,7,4,0,0,921,922,5,106,0,0,922,923,5,109,0,0,
        923,924,3,168,84,0,924,925,5,110,0,0,925,933,1,0,0,0,926,927,7,5,
        0,0,927,928,5,106,0,0,928,929,5,109,0,0,929,930,3,168,84,0,930,931,
        5,110,0,0,931,933,1,0,0,0,932,920,1,0,0,0,932,926,1,0,0,0,933,181,
        1,0,0,0,934,935,5,74,0,0,935,936,3,188,94,0,936,937,5,104,0,0,937,
        938,3,184,92,0,938,183,1,0,0,0,939,940,3,186,93,0,940,941,5,75,0,
        0,941,942,3,190,95,0,942,185,1,0,0,0,943,944,7,6,0,0,944,945,5,107,
        0,0,945,946,3,212,106,0,946,952,5,108,0,0,947,948,5,77,0,0,948,949,
        5,107,0,0,949,950,3,212,106,0,950,951,5,108,0,0,951,953,1,0,0,0,
        952,947,1,0,0,0,952,953,1,0,0,0,953,187,1,0,0,0,954,955,3,10,5,0,
        955,189,1,0,0,0,956,970,5,78,0,0,957,971,3,192,96,0,958,959,5,79,
        0,0,959,960,5,107,0,0,960,961,3,6,3,0,961,962,5,108,0,0,962,971,
        1,0,0,0,963,971,3,194,97,0,964,971,3,196,98,0,965,971,3,198,99,0,
        966,971,3,200,100,0,967,971,3,206,103,0,968,971,3,202,101,0,969,
        971,3,204,102,0,970,957,1,0,0,0,970,958,1,0,0,0,970,963,1,0,0,0,
        970,964,1,0,0,0,970,965,1,0,0,0,970,966,1,0,0,0,970,967,1,0,0,0,
        970,968,1,0,0,0,970,969,1,0,0,0,971,191,1,0,0,0,972,973,5,80,0,0,
        973,974,5,107,0,0,974,975,3,6,3,0,975,976,5,108,0,0,976,193,1,0,
        0,0,977,978,5,81,0,0,978,979,5,107,0,0,979,980,3,208,104,0,980,981,
        5,103,0,0,981,982,3,6,3,0,982,983,5,108,0,0,983,195,1,0,0,0,984,
        985,5,82,0,0,985,986,5,107,0,0,986,987,3,6,3,0,987,988,5,108,0,0,
        988,197,1,0,0,0,989,990,5,83,0,0,990,991,5,107,0,0,991,992,3,6,3,
        0,992,993,5,108,0,0,993,199,1,0,0,0,994,995,5,84,0,0,995,996,5,107,
        0,0,996,997,3,6,3,0,997,998,5,108,0,0,998,201,1,0,0,0,999,1000,5,
        85,0,0,1000,1001,5,107,0,0,1001,1002,3,210,105,0,1002,1003,5,103,
        0,0,1003,1004,3,6,3,0,1004,1005,5,108,0,0,1005,203,1,0,0,0,1006,
        1007,5,86,0,0,1007,1008,5,107,0,0,1008,1009,3,210,105,0,1009,1010,
        5,103,0,0,1010,1011,3,6,3,0,1011,1012,5,108,0,0,1012,205,1,0,0,0,
        1013,1014,5,87,0,0,1014,1015,5,107,0,0,1015,1016,3,6,3,0,1016,1017,
        5,108,0,0,1017,207,1,0,0,0,1018,1019,3,6,3,0,1019,209,1,0,0,0,1020,
        1021,3,6,3,0,1021,211,1,0,0,0,1022,1023,6,106,-1,0,1023,1077,3,8,
        4,0,1024,1077,3,216,108,0,1025,1077,3,224,112,0,1026,1027,5,107,
        0,0,1027,1028,3,212,106,0,1028,1029,5,108,0,0,1029,1077,1,0,0,0,
        1030,1031,5,115,0,0,1031,1077,3,212,106,17,1032,1033,5,88,0,0,1033,
        1077,3,212,106,16,1034,1035,5,89,0,0,1035,1077,3,212,106,15,1036,
        1037,5,90,0,0,1037,1077,3,212,106,14,1038,1039,5,91,0,0,1039,1077,
        3,212,106,13,1040,1041,5,92,0,0,1041,1077,3,212,106,12,1042,1043,
        5,93,0,0,1043,1077,3,212,106,11,1044,1045,5,94,0,0,1045,1077,3,212,
        106,10,1046,1047,5,95,0,0,1047,1077,3,212,106,9,1048,1049,5,96,0,
        0,1049,1077,3,212,106,8,1050,1051,5,97,0,0,1051,1077,3,212,106,7,
        1052,1053,5,98,0,0,1053,1077,3,212,106,6,1054,1055,5,99,0,0,1055,
        1077,3,212,106,5,1056,1057,5,100,0,0,1057,1058,5,107,0,0,1058,1059,
        3,214,107,0,1059,1060,5,108,0,0,1060,1077,1,0,0,0,1061,1062,5,176,
        0,0,1062,1063,5,107,0,0,1063,1064,3,214,107,0,1064,1065,5,108,0,
        0,1065,1077,1,0,0,0,1066,1067,5,177,0,0,1067,1068,5,107,0,0,1068,
        1069,3,214,107,0,1069,1070,5,108,0,0,1070,1077,1,0,0,0,1071,1072,
        5,101,0,0,1072,1073,5,107,0,0,1073,1074,3,214,107,0,1074,1075,5,
        108,0,0,1075,1077,1,0,0,0,1076,1022,1,0,0,0,1076,1024,1,0,0,0,1076,
        1025,1,0,0,0,1076,1026,1,0,0,0,1076,1030,1,0,0,0,1076,1032,1,0,0,
        0,1076,1034,1,0,0,0,1076,1036,1,0,0,0,1076,1038,1,0,0,0,1076,1040,
        1,0,0,0,1076,1042,1,0,0,0,1076,1044,1,0,0,0,1076,1046,1,0,0,0,1076,
        1048,1,0,0,0,1076,1050,1,0,0,0,1076,1052,1,0,0,0,1076,1054,1,0,0,
        0,1076,1056,1,0,0,0,1076,1061,1,0,0,0,1076,1066,1,0,0,0,1076,1071,
        1,0,0,0,1077,1094,1,0,0,0,1078,1079,10,21,0,0,1079,1080,7,7,0,0,
        1080,1093,3,212,106,22,1081,1082,10,20,0,0,1082,1083,7,8,0,0,1083,
        1093,3,212,106,21,1084,1085,10,19,0,0,1085,1086,3,218,109,0,1086,
        1087,3,212,106,20,1087,1093,1,0,0,0,1088,1089,10,18,0,0,1089,1090,
        3,220,110,0,1090,1091,3,212,106,19,1091,1093,1,0,0,0,1092,1078,1,
        0,0,0,1092,1081,1,0,0,0,1092,1084,1,0,0,0,1092,1088,1,0,0,0,1093,
        1096,1,0,0,0,1094,1092,1,0,0,0,1094,1095,1,0,0,0,1095,213,1,0,0,
        0,1096,1094,1,0,0,0,1097,1102,3,212,106,0,1098,1099,5,103,0,0,1099,
        1101,3,212,106,0,1100,1098,1,0,0,0,1101,1104,1,0,0,0,1102,1100,1,
        0,0,0,1102,1103,1,0,0,0,1103,1106,1,0,0,0,1104,1102,1,0,0,0,1105,
        1107,5,103,0,0,1106,1105,1,0,0,0,1106,1107,1,0,0,0,1107,215,1,0,
        0,0,1108,1109,7,9,0,0,1109,217,1,0,0,0,1110,1111,7,10,0,0,1111,219,
        1,0,0,0,1112,1113,7,11,0,0,1113,221,1,0,0,0,1114,1115,7,12,0,0,1115,
        223,1,0,0,0,1116,1117,5,102,0,0,1117,1119,3,226,113,0,1118,1120,
        3,228,114,0,1119,1118,1,0,0,0,1119,1120,1,0,0,0,1120,225,1,0,0,0,
        1121,1122,3,10,5,0,1122,227,1,0,0,0,1123,1124,3,16,8,0,1124,229,
        1,0,0,0,81,247,251,258,262,269,273,277,286,293,297,300,303,308,316,
        320,325,343,347,356,371,379,391,393,396,408,434,438,444,460,464,
        470,484,488,494,503,517,523,537,541,547,552,562,566,580,605,671,
        676,683,696,717,721,726,733,760,765,768,773,779,796,803,811,817,
        824,832,840,852,861,874,880,887,894,898,932,952,970,1076,1092,1094,
        1102,1106,1119
    ]

class appgenParser ( Parser ):

    grammarFileName = "appgen.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'name'", "'bit'", "'boolean'", "'tinyint'", 
                     "'smallint'", "'int'", "'integer'", "'bigint'", "'double'", 
                     "'decimal'", "'float'", "'money'", "'smallmoney'", 
                     "'char'", "'nchar'", "'nvarchar'", "'text'", "'mediumtext'", 
                     "'longtext'", "'xml'", "'document'", "'mediumblob'", 
                     "'longblob'", "'binary'", "'varbinary'", "'json'", 
                     "'jsonb'", "'interval'", "'time'", "'timestamp'", "'timestamptz'", 
                     "'timestampltz'", "'datetime'", "'date'", "'geography'", 
                     "'geometry'", "'point'", "'hllsketch'", "'hstore'", 
                     "'pseudo_type'", "'super'", "'serial'", "'smallserial'", 
                     "'bigserial'", "'uniqueidentifier'", "'rowversion'", 
                     "'variant'", "'inet'", "'image'", "'object'", "'uuid'", 
                     "'array'", "'of'", "'CURRENT_DATE'", "'CURRENT_USER'", 
                     "'index'", "'on'", "'of type'", "'btree'", "'gin'", 
                     "'gist'", "'hash'", "'indexes'", "'views'", "'add'", 
                     "'show'", "'list'", "'edit'", "'all'", "'ex'", "'exclude'", 
                     "'in'", "'include'", "'rule'", "'then'", "'if'", "'else'", 
                     "'action'", "'email'", "'python'", "'sms'", "'NOTIFY'", 
                     "'search'", "'flag'", "'upload'", "'download'", "'execute_query'", 
                     "'sin'", "'cos'", "'tan'", "'asin'", "'acos'", "'atan'", 
                     "'sinh'", "'cosh'", "'tanh'", "'asinh'", "'acosh'", 
                     "'atanh'", "'avg'", "'sum'", "'exec'", "','", "':'", 
                     "';'", "'='", "'('", "')'", "'['", "']'", "'{'", "'}'", 
                     "'.'", "'+'", "'-'", "'/'", "'*'", "'<'", "'>'", "<INVALID>", 
                     "'!='", "'<='", "'>='", "'&&'", "'||'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'required'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'#import'", "'#include'", "'display'", 
                     "'version'", "'dialect'", "<INVALID>", "'cache'", "'check'", 
                     "'project'", "<INVALID>", "'varchar'", "'note'", "'mode'", 
                     "'ref'", "'table'", "'mixin'", "'tablegroup'", "'report'", 
                     "'view'", "'dbview'", "'dbfunc'", "'config'", "'generate'", 
                     "'deployment'", "'languages'", "'theme'", "'enum'", 
                     "'chart'", "'min'", "'max'", "'default'", "'default-expression'", 
                     "'blob'", "'file'", "'public'", "'pk'", "'primary_key'", 
                     "'ios'", "'web'", "'sql'", "'desktop'", "'os'", "'android'", 
                     "'psql'", "'mysql'", "'sqlite'", "'oracle'", "'mssql'", 
                     "'nullable'", "'now'", "'today'", "'yesterday'", "'tomorrow'", 
                     "'dev_db_uri'", "'prod_db_uri'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "COMMA", "COLON", 
                      "SEMI_COLON", "EQ", "L_PAR", "R_PAR", "L_SQUARE", 
                      "R_SQUARE", "L_CURLY", "R_CURLY", "DOT", "ADD", "SUB", 
                      "DIV", "MUL", "LT", "GT", "M2M", "NEQ", "LTE", "GTE", 
                      "AND", "OR", "WS", "NL", "C_LINE_COMMENT", "C_STYLE_COMMENT", 
                      "IDENT", "STRING", "INT", "NUMBER", "FLOAT", "TRUE", 
                      "FALSE", "BOOL", "HEX", "DECIMAL", "TIME_INTERVAL", 
                      "DATE_TIME_LITERAL", "VersionLiteral", "REQUIRED", 
                      "INCR", "DECR", "NOT_NULL", "NULL", "IMPORT", "INCLUDE", 
                      "DISPLAY", "VERSION", "DIALECT", "UNIQ", "CACHE", 
                      "CHECK", "PROJECT", "TSERIES", "VARCHAR", "NOTE", 
                      "MODE", "REF", "TABLE", "MIXIN", "TBLGROUP", "REPORT", 
                      "VIEW", "DBVIEW", "DBFUNC", "CONFIG", "GENERATE", 
                      "DEPLOYMENT", "LANGUAGES", "THEME", "ENUM", "CHART", 
                      "MIN", "MAX", "DEFAULT", "DEFAULT_EXPR", "BLOB", "FILE", 
                      "PUBLIC", "PK_SHORT", "PK_LONG", "IOS", "WEB", "SQL", 
                      "DESKTOP", "OS", "ANDROID", "PGSQL", "MYSQL", "SQLITE", 
                      "ORACLE", "MSSQL", "NULLABLE", "NOW", "TODAY", "YESTERDAY", 
                      "TOMORROW", "DDB_URI", "PDB_URI" ]

    RULE_unique = 0
    RULE_db = 1
    RULE_int = 2
    RULE_string = 3
    RULE_ident = 4
    RULE_name_attr = 5
    RULE_int_list = 6
    RULE_ident_list = 7
    RULE_string_list = 8
    RULE_option = 9
    RULE_option_list = 10
    RULE_appgen = 11
    RULE_importDeclaration = 12
    RULE_import_file_list = 13
    RULE_import_file_name = 14
    RULE_projectBlock = 15
    RULE_project_name = 16
    RULE_project_property_list = 17
    RULE_project_property = 18
    RULE_gen_option = 19
    RULE_app_gen_target = 20
    RULE_deployment = 21
    RULE_deployment_option_list = 22
    RULE_language = 23
    RULE_lang_list = 24
    RULE_theme = 25
    RULE_report_spec = 26
    RULE_report_name = 27
    RULE_report_property_list = 28
    RULE_report_property = 29
    RULE_chart_specification = 30
    RULE_chart_name = 31
    RULE_chart_property_list = 32
    RULE_chart_property = 33
    RULE_config = 34
    RULE_config_options_list = 35
    RULE_config_option = 36
    RULE_statement = 37
    RULE_dbfunc = 38
    RULE_func_name = 39
    RULE_object = 40
    RULE_database = 41
    RULE_schema = 42
    RULE_mixin = 43
    RULE_mixin_name = 44
    RULE_column_list = 45
    RULE_column = 46
    RULE_column_name = 47
    RULE_column_option_list = 48
    RULE_primary_key = 49
    RULE_column_option = 50
    RULE_check_expr = 51
    RULE_data_type = 52
    RULE_column_reference = 53
    RULE_table_reference = 54
    RULE_column_default = 55
    RULE_enum_name = 56
    RULE_enum_internal = 57
    RULE_enum_out = 58
    RULE_enum_list = 59
    RULE_enum_item = 60
    RULE_enum_idx = 61
    RULE_enum_value = 62
    RULE_display_method = 63
    RULE_note_option = 64
    RULE_note_value = 65
    RULE_varchar = 66
    RULE_tableDecl = 67
    RULE_mixin_list = 68
    RULE_table_name = 69
    RULE_dbview = 70
    RULE_db_join = 71
    RULE_ref_internal = 72
    RULE_ext_ref = 73
    RULE_ref_name = 74
    RULE_ref_type = 75
    RULE_oneToOne = 76
    RULE_oneToMany = 77
    RULE_manyToOne = 78
    RULE_manyToMany = 79
    RULE_index_ext = 80
    RULE_index_int = 81
    RULE_index_item_list = 82
    RULE_index_item = 83
    RULE_column_names = 84
    RULE_index_name = 85
    RULE_view_s_spec = 86
    RULE_view_spec_list = 87
    RULE_view_spec = 88
    RULE_view_type = 89
    RULE_view_spec_options = 90
    RULE_business_rule = 91
    RULE_businessRule = 92
    RULE_ifExpr = 93
    RULE_rule_name = 94
    RULE_actionExpr = 95
    RULE_python_code = 96
    RULE_sms = 97
    RULE_notify = 98
    RULE_search = 99
    RULE_flag = 100
    RULE_upload = 101
    RULE_download = 102
    RULE_execute_query = 103
    RULE_destination = 104
    RULE_server_loc = 105
    RULE_expr = 106
    RULE_expr_list = 107
    RULE_literal = 108
    RULE_booleanOp = 109
    RULE_comparisonOp = 110
    RULE_arithmeticOp = 111
    RULE_functionCall = 112
    RULE_function_name = 113
    RULE_param_list = 114

    ruleNames =  [ "unique", "db", "int", "string", "ident", "name_attr", 
                   "int_list", "ident_list", "string_list", "option", "option_list", 
                   "appgen", "importDeclaration", "import_file_list", "import_file_name", 
                   "projectBlock", "project_name", "project_property_list", 
                   "project_property", "gen_option", "app_gen_target", "deployment", 
                   "deployment_option_list", "language", "lang_list", "theme", 
                   "report_spec", "report_name", "report_property_list", 
                   "report_property", "chart_specification", "chart_name", 
                   "chart_property_list", "chart_property", "config", "config_options_list", 
                   "config_option", "statement", "dbfunc", "func_name", 
                   "object", "database", "schema", "mixin", "mixin_name", 
                   "column_list", "column", "column_name", "column_option_list", 
                   "primary_key", "column_option", "check_expr", "data_type", 
                   "column_reference", "table_reference", "column_default", 
                   "enum_name", "enum_internal", "enum_out", "enum_list", 
                   "enum_item", "enum_idx", "enum_value", "display_method", 
                   "note_option", "note_value", "varchar", "tableDecl", 
                   "mixin_list", "table_name", "dbview", "db_join", "ref_internal", 
                   "ext_ref", "ref_name", "ref_type", "oneToOne", "oneToMany", 
                   "manyToOne", "manyToMany", "index_ext", "index_int", 
                   "index_item_list", "index_item", "column_names", "index_name", 
                   "view_s_spec", "view_spec_list", "view_spec", "view_type", 
                   "view_spec_options", "business_rule", "businessRule", 
                   "ifExpr", "rule_name", "actionExpr", "python_code", "sms", 
                   "notify", "search", "flag", "upload", "download", "execute_query", 
                   "destination", "server_loc", "expr", "expr_list", "literal", 
                   "booleanOp", "comparisonOp", "arithmeticOp", "functionCall", 
                   "function_name", "param_list" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    T__89=90
    T__90=91
    T__91=92
    T__92=93
    T__93=94
    T__94=95
    T__95=96
    T__96=97
    T__97=98
    T__98=99
    T__99=100
    T__100=101
    T__101=102
    COMMA=103
    COLON=104
    SEMI_COLON=105
    EQ=106
    L_PAR=107
    R_PAR=108
    L_SQUARE=109
    R_SQUARE=110
    L_CURLY=111
    R_CURLY=112
    DOT=113
    ADD=114
    SUB=115
    DIV=116
    MUL=117
    LT=118
    GT=119
    M2M=120
    NEQ=121
    LTE=122
    GTE=123
    AND=124
    OR=125
    WS=126
    NL=127
    C_LINE_COMMENT=128
    C_STYLE_COMMENT=129
    IDENT=130
    STRING=131
    INT=132
    NUMBER=133
    FLOAT=134
    TRUE=135
    FALSE=136
    BOOL=137
    HEX=138
    DECIMAL=139
    TIME_INTERVAL=140
    DATE_TIME_LITERAL=141
    VersionLiteral=142
    REQUIRED=143
    INCR=144
    DECR=145
    NOT_NULL=146
    NULL=147
    IMPORT=148
    INCLUDE=149
    DISPLAY=150
    VERSION=151
    DIALECT=152
    UNIQ=153
    CACHE=154
    CHECK=155
    PROJECT=156
    TSERIES=157
    VARCHAR=158
    NOTE=159
    MODE=160
    REF=161
    TABLE=162
    MIXIN=163
    TBLGROUP=164
    REPORT=165
    VIEW=166
    DBVIEW=167
    DBFUNC=168
    CONFIG=169
    GENERATE=170
    DEPLOYMENT=171
    LANGUAGES=172
    THEME=173
    ENUM=174
    CHART=175
    MIN=176
    MAX=177
    DEFAULT=178
    DEFAULT_EXPR=179
    BLOB=180
    FILE=181
    PUBLIC=182
    PK_SHORT=183
    PK_LONG=184
    IOS=185
    WEB=186
    SQL=187
    DESKTOP=188
    OS=189
    ANDROID=190
    PGSQL=191
    MYSQL=192
    SQLITE=193
    ORACLE=194
    MSSQL=195
    NULLABLE=196
    NOW=197
    TODAY=198
    YESTERDAY=199
    TOMORROW=200
    DDB_URI=201
    PDB_URI=202

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class UniqueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIQ(self):
            return self.getToken(appgenParser.UNIQ, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_unique

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnique" ):
                listener.enterUnique(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnique" ):
                listener.exitUnique(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnique" ):
                return visitor.visitUnique(self)
            else:
                return visitor.visitChildren(self)




    def unique(self):

        localctx = appgenParser.UniqueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_unique)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(appgenParser.UNIQ)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DbContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PGSQL(self):
            return self.getToken(appgenParser.PGSQL, 0)

        def MYSQL(self):
            return self.getToken(appgenParser.MYSQL, 0)

        def SQLITE(self):
            return self.getToken(appgenParser.SQLITE, 0)

        def ORACLE(self):
            return self.getToken(appgenParser.ORACLE, 0)

        def MSSQL(self):
            return self.getToken(appgenParser.MSSQL, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_db

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDb" ):
                listener.enterDb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDb" ):
                listener.exitDb(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDb" ):
                return visitor.visitDb(self)
            else:
                return visitor.visitChildren(self)




    def db(self):

        localctx = appgenParser.DbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_db)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            _la = self._input.LA(1)
            if not(((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(appgenParser.INT, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInt" ):
                listener.enterInt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInt" ):
                listener.exitInt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInt" ):
                return visitor.visitInt(self)
            else:
                return visitor.visitChildren(self)




    def int_(self):

        localctx = appgenParser.IntContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_int)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.match(appgenParser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(appgenParser.STRING, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_string

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString" ):
                listener.enterString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString" ):
                listener.exitString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitString" ):
                return visitor.visitString(self)
            else:
                return visitor.visitChildren(self)




    def string(self):

        localctx = appgenParser.StringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_string)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(appgenParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(appgenParser.IDENT, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_ident

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdent" ):
                listener.enterIdent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdent" ):
                listener.exitIdent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdent" ):
                return visitor.visitIdent(self)
            else:
                return visitor.visitChildren(self)




    def ident(self):

        localctx = appgenParser.IdentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_ident)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.match(appgenParser.IDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Name_attrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ident(self):
            return self.getTypedRuleContext(appgenParser.IdentContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_name_attr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName_attr" ):
                listener.enterName_attr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName_attr" ):
                listener.exitName_attr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName_attr" ):
                return visitor.visitName_attr(self)
            else:
                return visitor.visitChildren(self)




    def name_attr(self):

        localctx = appgenParser.Name_attrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_name_attr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.ident()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Int_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def int_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.IntContext)
            else:
                return self.getTypedRuleContext(appgenParser.IntContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_int_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInt_list" ):
                listener.enterInt_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInt_list" ):
                listener.exitInt_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInt_list" ):
                return visitor.visitInt_list(self)
            else:
                return visitor.visitChildren(self)




    def int_list(self):

        localctx = appgenParser.Int_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_int_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self.int_()
            self.state = 247
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 243
                    self.match(appgenParser.COMMA)
                    self.state = 244
                    self.int_() 
                self.state = 249
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 250
                self.match(appgenParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ident_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ident(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.IdentContext)
            else:
                return self.getTypedRuleContext(appgenParser.IdentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_ident_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdent_list" ):
                listener.enterIdent_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdent_list" ):
                listener.exitIdent_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdent_list" ):
                return visitor.visitIdent_list(self)
            else:
                return visitor.visitChildren(self)




    def ident_list(self):

        localctx = appgenParser.Ident_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ident_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.ident()
            self.state = 258
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 254
                    self.match(appgenParser.COMMA)
                    self.state = 255
                    self.ident() 
                self.state = 260
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

            self.state = 262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 261
                self.match(appgenParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.StringContext)
            else:
                return self.getTypedRuleContext(appgenParser.StringContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_string_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_list" ):
                listener.enterString_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_list" ):
                listener.exitString_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitString_list" ):
                return visitor.visitString_list(self)
            else:
                return visitor.visitChildren(self)




    def string_list(self):

        localctx = appgenParser.String_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_string_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.string()
            self.state = 269
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 265
                    self.match(appgenParser.COMMA)
                    self.state = 266
                    self.string() 
                self.state = 271
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

            self.state = 273
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 272
                self.match(appgenParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def ident(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.IdentContext)
            else:
                return self.getTypedRuleContext(appgenParser.IdentContext,i)


        def string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.StringContext)
            else:
                return self.getTypedRuleContext(appgenParser.StringContext,i)


        def string_list(self):
            return self.getTypedRuleContext(appgenParser.String_listContext,0)


        def ident_list(self):
            return self.getTypedRuleContext(appgenParser.Ident_listContext,0)


        def int_list(self):
            return self.getTypedRuleContext(appgenParser.Int_listContext,0)


        def int_(self):
            return self.getTypedRuleContext(appgenParser.IntContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOption" ):
                listener.enterOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOption" ):
                listener.exitOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOption" ):
                return visitor.visitOption(self)
            else:
                return visitor.visitChildren(self)




    def option(self):

        localctx = appgenParser.OptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_option)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [130]:
                self.state = 275
                self.ident()
                pass
            elif token in [131]:
                self.state = 276
                self.string()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 279
            self.match(appgenParser.EQ)
            self.state = 286
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 280
                self.string()
                pass

            elif la_ == 2:
                self.state = 281
                self.string_list()
                pass

            elif la_ == 3:
                self.state = 282
                self.ident()
                pass

            elif la_ == 4:
                self.state = 283
                self.ident_list()
                pass

            elif la_ == 5:
                self.state = 284
                self.int_list()
                pass

            elif la_ == 6:
                self.state = 285
                self.int_()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Option_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.OptionContext)
            else:
                return self.getTypedRuleContext(appgenParser.OptionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_option_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOption_list" ):
                listener.enterOption_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOption_list" ):
                listener.exitOption_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOption_list" ):
                return visitor.visitOption_list(self)
            else:
                return visitor.visitChildren(self)




    def option_list(self):

        localctx = appgenParser.Option_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_option_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.option()
            self.state = 293
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 289
                    self.match(appgenParser.COMMA)
                    self.state = 290
                    self.option() 
                self.state = 295
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

            self.state = 297
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.state = 296
                self.match(appgenParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AppgenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(appgenParser.EOF, 0)

        def importDeclaration(self):
            return self.getTypedRuleContext(appgenParser.ImportDeclarationContext,0)


        def projectBlock(self):
            return self.getTypedRuleContext(appgenParser.ProjectBlockContext,0)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.StatementContext)
            else:
                return self.getTypedRuleContext(appgenParser.StatementContext,i)


        def getRuleIndex(self):
            return appgenParser.RULE_appgen

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppgen" ):
                listener.enterAppgen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppgen" ):
                listener.exitAppgen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAppgen" ):
                return visitor.visitAppgen(self)
            else:
                return visitor.visitChildren(self)




    def appgen(self):

        localctx = appgenParser.AppgenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_appgen)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==148 or _la==149:
                self.state = 299
                self.importDeclaration()


            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==156:
                self.state = 302
                self.projectBlock()


            self.state = 306 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 305
                self.statement()
                self.state = 308 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==56 or _la==74 or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & 4521619162660865) != 0)):
                    break

            self.state = 310
            self.match(appgenParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(appgenParser.IMPORT, 0)

        def import_file_list(self):
            return self.getTypedRuleContext(appgenParser.Import_file_listContext,0)


        def INCLUDE(self):
            return self.getToken(appgenParser.INCLUDE, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_importDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportDeclaration" ):
                listener.enterImportDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportDeclaration" ):
                listener.exitImportDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportDeclaration" ):
                return visitor.visitImportDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def importDeclaration(self):

        localctx = appgenParser.ImportDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_importDeclaration)
        try:
            self.state = 316
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [148]:
                self.enterOuterAlt(localctx, 1)
                self.state = 312
                self.match(appgenParser.IMPORT)
                self.state = 313
                self.import_file_list()
                pass
            elif token in [149]:
                self.enterOuterAlt(localctx, 2)
                self.state = 314
                self.match(appgenParser.INCLUDE)
                self.state = 315
                self.import_file_list()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Import_file_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def import_file_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Import_file_nameContext)
            else:
                return self.getTypedRuleContext(appgenParser.Import_file_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_import_file_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImport_file_list" ):
                listener.enterImport_file_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImport_file_list" ):
                listener.exitImport_file_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImport_file_list" ):
                return visitor.visitImport_file_list(self)
            else:
                return visitor.visitChildren(self)




    def import_file_list(self):

        localctx = appgenParser.Import_file_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_import_file_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.import_file_name()
            self.state = 325
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 320
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==103:
                        self.state = 319
                        self.match(appgenParser.COMMA)


                    self.state = 322
                    self.import_file_name() 
                self.state = 327
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Import_file_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ident(self):
            return self.getTypedRuleContext(appgenParser.IdentContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_import_file_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImport_file_name" ):
                listener.enterImport_file_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImport_file_name" ):
                listener.exitImport_file_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImport_file_name" ):
                return visitor.visitImport_file_name(self)
            else:
                return visitor.visitChildren(self)




    def import_file_name(self):

        localctx = appgenParser.Import_file_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_import_file_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.ident()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROJECT(self):
            return self.getToken(appgenParser.PROJECT, 0)

        def project_name(self):
            return self.getTypedRuleContext(appgenParser.Project_nameContext,0)


        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def project_property_list(self):
            return self.getTypedRuleContext(appgenParser.Project_property_listContext,0)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_projectBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjectBlock" ):
                listener.enterProjectBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjectBlock" ):
                listener.exitProjectBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProjectBlock" ):
                return visitor.visitProjectBlock(self)
            else:
                return visitor.visitChildren(self)




    def projectBlock(self):

        localctx = appgenParser.ProjectBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_projectBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            self.match(appgenParser.PROJECT)
            self.state = 331
            self.project_name()
            self.state = 332
            self.match(appgenParser.L_CURLY)
            self.state = 333
            self.project_property_list()
            self.state = 334
            self.match(appgenParser.R_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Project_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_project_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject_name" ):
                listener.enterProject_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject_name" ):
                listener.exitProject_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProject_name" ):
                return visitor.visitProject_name(self)
            else:
                return visitor.visitChildren(self)




    def project_name(self):

        localctx = appgenParser.Project_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_project_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Project_property_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project_property(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Project_propertyContext)
            else:
                return self.getTypedRuleContext(appgenParser.Project_propertyContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_project_property_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject_property_list" ):
                listener.enterProject_property_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject_property_list" ):
                listener.exitProject_property_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProject_property_list" ):
                return visitor.visitProject_property_list(self)
            else:
                return visitor.visitChildren(self)




    def project_property_list(self):

        localctx = appgenParser.Project_property_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_project_property_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.project_property()
            self.state = 343
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 339
                    self.match(appgenParser.COMMA)
                    self.state = 340
                    self.project_property() 
                self.state = 345
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

            self.state = 347
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 346
                self.match(appgenParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Project_propertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def VERSION(self):
            return self.getToken(appgenParser.VERSION, 0)

        def DDB_URI(self):
            return self.getToken(appgenParser.DDB_URI, 0)

        def PDB_URI(self):
            return self.getToken(appgenParser.PDB_URI, 0)

        def config(self):
            return self.getTypedRuleContext(appgenParser.ConfigContext,0)


        def deployment(self):
            return self.getTypedRuleContext(appgenParser.DeploymentContext,0)


        def language(self):
            return self.getTypedRuleContext(appgenParser.LanguageContext,0)


        def report_spec(self):
            return self.getTypedRuleContext(appgenParser.Report_specContext,0)


        def theme(self):
            return self.getTypedRuleContext(appgenParser.ThemeContext,0)


        def gen_option(self):
            return self.getTypedRuleContext(appgenParser.Gen_optionContext,0)


        def option(self):
            return self.getTypedRuleContext(appgenParser.OptionContext,0)


        def VersionLiteral(self):
            return self.getToken(appgenParser.VersionLiteral, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_project_property

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject_property" ):
                listener.enterProject_property(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject_property" ):
                listener.exitProject_property(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProject_property" ):
                return visitor.visitProject_property(self)
            else:
                return visitor.visitChildren(self)




    def project_property(self):

        localctx = appgenParser.Project_propertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_project_property)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 371
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1]:
                self.state = 349
                self.match(appgenParser.T__0)
                self.state = 350
                self.match(appgenParser.EQ)
                self.state = 351
                self.string()
                pass
            elif token in [151]:
                self.state = 352
                self.match(appgenParser.VERSION)
                self.state = 353
                self.match(appgenParser.EQ)
                self.state = 356
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [131]:
                    self.state = 354
                    self.string()
                    pass
                elif token in [142]:
                    self.state = 355
                    self.match(appgenParser.VersionLiteral)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [201]:
                self.state = 358
                self.match(appgenParser.DDB_URI)
                self.state = 359
                self.match(appgenParser.EQ)
                self.state = 360
                self.string()
                pass
            elif token in [202]:
                self.state = 361
                self.match(appgenParser.PDB_URI)
                self.state = 362
                self.match(appgenParser.EQ)
                self.state = 363
                self.string()
                pass
            elif token in [169]:
                self.state = 364
                self.config()
                pass
            elif token in [171]:
                self.state = 365
                self.deployment()
                pass
            elif token in [172]:
                self.state = 366
                self.language()
                pass
            elif token in [165]:
                self.state = 367
                self.report_spec()
                pass
            elif token in [173]:
                self.state = 368
                self.theme()
                pass
            elif token in [170]:
                self.state = 369
                self.gen_option()
                pass
            elif token in [130, 131]:
                self.state = 370
                self.option()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Gen_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GENERATE(self):
            return self.getToken(appgenParser.GENERATE, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def L_SQUARE(self):
            return self.getToken(appgenParser.L_SQUARE, 0)

        def R_SQUARE(self):
            return self.getToken(appgenParser.R_SQUARE, 0)

        def app_gen_target(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.App_gen_targetContext)
            else:
                return self.getTypedRuleContext(appgenParser.App_gen_targetContext,i)


        def getRuleIndex(self):
            return appgenParser.RULE_gen_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGen_option" ):
                listener.enterGen_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGen_option" ):
                listener.exitGen_option(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGen_option" ):
                return visitor.visitGen_option(self)
            else:
                return visitor.visitChildren(self)




    def gen_option(self):

        localctx = appgenParser.Gen_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_gen_option)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            self.match(appgenParser.GENERATE)
            self.state = 374
            self.match(appgenParser.EQ)
            self.state = 375
            self.match(appgenParser.L_SQUARE)
            self.state = 377 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 376
                self.app_gen_target()
                self.state = 379 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & 846676729945653249) != 0)):
                    break

            self.state = 381
            self.match(appgenParser.R_SQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class App_gen_targetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IOS(self):
            return self.getToken(appgenParser.IOS, 0)

        def WEB(self):
            return self.getToken(appgenParser.WEB, 0)

        def DESKTOP(self):
            return self.getToken(appgenParser.DESKTOP, 0)

        def ANDROID(self):
            return self.getToken(appgenParser.ANDROID, 0)

        def SQL(self):
            return self.getToken(appgenParser.SQL, 0)

        def DIALECT(self):
            return self.getToken(appgenParser.DIALECT, 0)

        def db(self):
            return self.getTypedRuleContext(appgenParser.DbContext,0)


        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_app_gen_target

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterApp_gen_target" ):
                listener.enterApp_gen_target(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitApp_gen_target" ):
                listener.exitApp_gen_target(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitApp_gen_target" ):
                return visitor.visitApp_gen_target(self)
            else:
                return visitor.visitChildren(self)




    def app_gen_target(self):

        localctx = appgenParser.App_gen_targetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_app_gen_target)
        self._la = 0 # Token type
        try:
            self.state = 396
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [185]:
                self.enterOuterAlt(localctx, 1)
                self.state = 383
                self.match(appgenParser.IOS)
                pass
            elif token in [186]:
                self.enterOuterAlt(localctx, 2)
                self.state = 384
                self.match(appgenParser.WEB)
                pass
            elif token in [188]:
                self.enterOuterAlt(localctx, 3)
                self.state = 385
                self.match(appgenParser.DESKTOP)
                pass
            elif token in [190]:
                self.enterOuterAlt(localctx, 4)
                self.state = 386
                self.match(appgenParser.ANDROID)
                pass
            elif token in [187]:
                self.enterOuterAlt(localctx, 5)
                self.state = 387
                self.match(appgenParser.SQL)
                self.state = 393
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==152:
                    self.state = 388
                    self.match(appgenParser.DIALECT)
                    self.state = 391
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [191, 192, 193, 194, 195]:
                        self.state = 389
                        self.db()
                        pass
                    elif token in [131]:
                        self.state = 390
                        self.string()
                        pass
                    else:
                        raise NoViableAltException(self)



                pass
            elif token in [131]:
                self.enterOuterAlt(localctx, 6)
                self.state = 395
                self.string()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeploymentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEPLOYMENT(self):
            return self.getToken(appgenParser.DEPLOYMENT, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def deployment_option_list(self):
            return self.getTypedRuleContext(appgenParser.Deployment_option_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_deployment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeployment" ):
                listener.enterDeployment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeployment" ):
                listener.exitDeployment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeployment" ):
                return visitor.visitDeployment(self)
            else:
                return visitor.visitChildren(self)




    def deployment(self):

        localctx = appgenParser.DeploymentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_deployment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.match(appgenParser.DEPLOYMENT)
            self.state = 399
            self.match(appgenParser.EQ)
            self.state = 400
            self.deployment_option_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Deployment_option_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_SQUARE(self):
            return self.getToken(appgenParser.L_SQUARE, 0)

        def option_list(self):
            return self.getTypedRuleContext(appgenParser.Option_listContext,0)


        def R_SQUARE(self):
            return self.getToken(appgenParser.R_SQUARE, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_deployment_option_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeployment_option_list" ):
                listener.enterDeployment_option_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeployment_option_list" ):
                listener.exitDeployment_option_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeployment_option_list" ):
                return visitor.visitDeployment_option_list(self)
            else:
                return visitor.visitChildren(self)




    def deployment_option_list(self):

        localctx = appgenParser.Deployment_option_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_deployment_option_list)
        try:
            self.state = 408
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 402
                self.match(appgenParser.L_SQUARE)
                self.state = 403
                self.option_list()
                self.state = 404
                self.match(appgenParser.R_SQUARE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 406
                self.match(appgenParser.L_SQUARE)
                self.state = 407
                self.match(appgenParser.R_SQUARE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LanguageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LANGUAGES(self):
            return self.getToken(appgenParser.LANGUAGES, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def lang_list(self):
            return self.getTypedRuleContext(appgenParser.Lang_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_language

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLanguage" ):
                listener.enterLanguage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLanguage" ):
                listener.exitLanguage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLanguage" ):
                return visitor.visitLanguage(self)
            else:
                return visitor.visitChildren(self)




    def language(self):

        localctx = appgenParser.LanguageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_language)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.match(appgenParser.LANGUAGES)
            self.state = 411
            self.match(appgenParser.EQ)
            self.state = 412
            self.lang_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Lang_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_SQUARE(self):
            return self.getToken(appgenParser.L_SQUARE, 0)

        def string_list(self):
            return self.getTypedRuleContext(appgenParser.String_listContext,0)


        def R_SQUARE(self):
            return self.getToken(appgenParser.R_SQUARE, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_lang_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLang_list" ):
                listener.enterLang_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLang_list" ):
                listener.exitLang_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLang_list" ):
                return visitor.visitLang_list(self)
            else:
                return visitor.visitChildren(self)




    def lang_list(self):

        localctx = appgenParser.Lang_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_lang_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 414
            self.match(appgenParser.L_SQUARE)
            self.state = 415
            self.string_list()
            self.state = 416
            self.match(appgenParser.R_SQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThemeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THEME(self):
            return self.getToken(appgenParser.THEME, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_theme

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTheme" ):
                listener.enterTheme(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTheme" ):
                listener.exitTheme(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTheme" ):
                return visitor.visitTheme(self)
            else:
                return visitor.visitChildren(self)




    def theme(self):

        localctx = appgenParser.ThemeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_theme)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            self.match(appgenParser.THEME)
            self.state = 419
            self.match(appgenParser.EQ)
            self.state = 420
            self.string()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Report_specContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPORT(self):
            return self.getToken(appgenParser.REPORT, 0)

        def report_name(self):
            return self.getTypedRuleContext(appgenParser.Report_nameContext,0)


        def report_property_list(self):
            return self.getTypedRuleContext(appgenParser.Report_property_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_report_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReport_spec" ):
                listener.enterReport_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReport_spec" ):
                listener.exitReport_spec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReport_spec" ):
                return visitor.visitReport_spec(self)
            else:
                return visitor.visitChildren(self)




    def report_spec(self):

        localctx = appgenParser.Report_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_report_spec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.match(appgenParser.REPORT)
            self.state = 423
            self.report_name()
            self.state = 424
            self.report_property_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Report_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_report_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReport_name" ):
                listener.enterReport_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReport_name" ):
                listener.exitReport_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReport_name" ):
                return visitor.visitReport_name(self)
            else:
                return visitor.visitChildren(self)




    def report_name(self):

        localctx = appgenParser.Report_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_report_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 426
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Report_property_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def report_property(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Report_propertyContext)
            else:
                return self.getTypedRuleContext(appgenParser.Report_propertyContext,i)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_report_property_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReport_property_list" ):
                listener.enterReport_property_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReport_property_list" ):
                listener.exitReport_property_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReport_property_list" ):
                return visitor.visitReport_property_list(self)
            else:
                return visitor.visitChildren(self)




    def report_property_list(self):

        localctx = appgenParser.Report_property_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_report_property_list)
        self._la = 0 # Token type
        try:
            self.state = 444
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 428
                self.match(appgenParser.L_CURLY)
                self.state = 429
                self.report_property()
                self.state = 434
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 430
                        self.match(appgenParser.COMMA)
                        self.state = 431
                        self.report_property() 
                    self.state = 436
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

                self.state = 438
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==103:
                    self.state = 437
                    self.match(appgenParser.COMMA)


                self.state = 440
                self.match(appgenParser.R_CURLY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 442
                self.match(appgenParser.L_CURLY)
                self.state = 443
                self.match(appgenParser.R_CURLY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Report_propertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def option(self):
            return self.getTypedRuleContext(appgenParser.OptionContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_report_property

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReport_property" ):
                listener.enterReport_property(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReport_property" ):
                listener.exitReport_property(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReport_property" ):
                return visitor.visitReport_property(self)
            else:
                return visitor.visitChildren(self)




    def report_property(self):

        localctx = appgenParser.Report_propertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_report_property)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 446
            self.option()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Chart_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHART(self):
            return self.getToken(appgenParser.CHART, 0)

        def chart_name(self):
            return self.getTypedRuleContext(appgenParser.Chart_nameContext,0)


        def chart_property_list(self):
            return self.getTypedRuleContext(appgenParser.Chart_property_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_chart_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChart_specification" ):
                listener.enterChart_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChart_specification" ):
                listener.exitChart_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChart_specification" ):
                return visitor.visitChart_specification(self)
            else:
                return visitor.visitChildren(self)




    def chart_specification(self):

        localctx = appgenParser.Chart_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_chart_specification)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 448
            self.match(appgenParser.CHART)
            self.state = 449
            self.chart_name()
            self.state = 450
            self.chart_property_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Chart_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_chart_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChart_name" ):
                listener.enterChart_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChart_name" ):
                listener.exitChart_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChart_name" ):
                return visitor.visitChart_name(self)
            else:
                return visitor.visitChildren(self)




    def chart_name(self):

        localctx = appgenParser.Chart_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_chart_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 452
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Chart_property_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def chart_property(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Chart_propertyContext)
            else:
                return self.getTypedRuleContext(appgenParser.Chart_propertyContext,i)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_chart_property_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChart_property_list" ):
                listener.enterChart_property_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChart_property_list" ):
                listener.exitChart_property_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChart_property_list" ):
                return visitor.visitChart_property_list(self)
            else:
                return visitor.visitChildren(self)




    def chart_property_list(self):

        localctx = appgenParser.Chart_property_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_chart_property_list)
        self._la = 0 # Token type
        try:
            self.state = 470
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 454
                self.match(appgenParser.L_CURLY)
                self.state = 455
                self.chart_property()
                self.state = 460
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,28,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 456
                        self.match(appgenParser.COMMA)
                        self.state = 457
                        self.chart_property() 
                    self.state = 462
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

                self.state = 464
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==103:
                    self.state = 463
                    self.match(appgenParser.COMMA)


                self.state = 466
                self.match(appgenParser.R_CURLY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 468
                self.match(appgenParser.L_CURLY)
                self.state = 469
                self.match(appgenParser.R_CURLY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Chart_propertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def option(self):
            return self.getTypedRuleContext(appgenParser.OptionContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_chart_property

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChart_property" ):
                listener.enterChart_property(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChart_property" ):
                listener.exitChart_property(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChart_property" ):
                return visitor.visitChart_property(self)
            else:
                return visitor.visitChildren(self)




    def chart_property(self):

        localctx = appgenParser.Chart_propertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_chart_property)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            self.option()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONFIG(self):
            return self.getToken(appgenParser.CONFIG, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def config_options_list(self):
            return self.getTypedRuleContext(appgenParser.Config_options_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_config

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfig" ):
                listener.enterConfig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfig" ):
                listener.exitConfig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfig" ):
                return visitor.visitConfig(self)
            else:
                return visitor.visitChildren(self)




    def config(self):

        localctx = appgenParser.ConfigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_config)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 474
            self.match(appgenParser.CONFIG)
            self.state = 475
            self.match(appgenParser.EQ)
            self.state = 476
            self.config_options_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Config_options_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def config_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Config_optionContext)
            else:
                return self.getTypedRuleContext(appgenParser.Config_optionContext,i)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_config_options_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfig_options_list" ):
                listener.enterConfig_options_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfig_options_list" ):
                listener.exitConfig_options_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfig_options_list" ):
                return visitor.visitConfig_options_list(self)
            else:
                return visitor.visitChildren(self)




    def config_options_list(self):

        localctx = appgenParser.Config_options_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_config_options_list)
        self._la = 0 # Token type
        try:
            self.state = 494
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 478
                self.match(appgenParser.L_CURLY)
                self.state = 479
                self.config_option()
                self.state = 484
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 480
                        self.match(appgenParser.COMMA)
                        self.state = 481
                        self.config_option() 
                    self.state = 486
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                self.state = 488
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==103:
                    self.state = 487
                    self.match(appgenParser.COMMA)


                self.state = 490
                self.match(appgenParser.R_CURLY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 492
                self.match(appgenParser.L_CURLY)
                self.state = 493
                self.match(appgenParser.R_CURLY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Config_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def option(self):
            return self.getTypedRuleContext(appgenParser.OptionContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_config_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfig_option" ):
                listener.enterConfig_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfig_option" ):
                listener.exitConfig_option(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfig_option" ):
                return visitor.visitConfig_option(self)
            else:
                return visitor.visitChildren(self)




    def config_option(self):

        localctx = appgenParser.Config_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_config_option)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.option()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def object_(self):
            return self.getTypedRuleContext(appgenParser.ObjectContext,0)


        def ext_ref(self):
            return self.getTypedRuleContext(appgenParser.Ext_refContext,0)


        def enum_out(self):
            return self.getTypedRuleContext(appgenParser.Enum_outContext,0)


        def index_ext(self):
            return self.getTypedRuleContext(appgenParser.Index_extContext,0)


        def business_rule(self):
            return self.getTypedRuleContext(appgenParser.Business_ruleContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = appgenParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 503
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [130, 162, 163, 167, 168, 182]:
                self.state = 498
                self.object_()
                pass
            elif token in [161]:
                self.state = 499
                self.ext_ref()
                pass
            elif token in [174]:
                self.state = 500
                self.enum_out()
                pass
            elif token in [56]:
                self.state = 501
                self.index_ext()
                pass
            elif token in [74]:
                self.state = 502
                self.business_rule()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DbfuncContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DBFUNC(self):
            return self.getToken(appgenParser.DBFUNC, 0)

        def func_name(self):
            return self.getTypedRuleContext(appgenParser.Func_nameContext,0)


        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_dbfunc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDbfunc" ):
                listener.enterDbfunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDbfunc" ):
                listener.exitDbfunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDbfunc" ):
                return visitor.visitDbfunc(self)
            else:
                return visitor.visitChildren(self)




    def dbfunc(self):

        localctx = appgenParser.DbfuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_dbfunc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 505
            self.match(appgenParser.DBFUNC)
            self.state = 506
            self.func_name()
            self.state = 507
            self.string()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Func_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_func_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_name" ):
                listener.enterFunc_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_name" ):
                listener.exitFunc_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc_name" ):
                return visitor.visitFunc_name(self)
            else:
                return visitor.visitChildren(self)




    def func_name(self):

        localctx = appgenParser.Func_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_func_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 509
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def database(self):
            return self.getTypedRuleContext(appgenParser.DatabaseContext,0)


        def schema(self):
            return self.getTypedRuleContext(appgenParser.SchemaContext,0)


        def tableDecl(self):
            return self.getTypedRuleContext(appgenParser.TableDeclContext,0)


        def mixin(self):
            return self.getTypedRuleContext(appgenParser.MixinContext,0)


        def dbview(self):
            return self.getTypedRuleContext(appgenParser.DbviewContext,0)


        def dbfunc(self):
            return self.getTypedRuleContext(appgenParser.DbfuncContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_object

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObject" ):
                listener.enterObject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObject" ):
                listener.exitObject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObject" ):
                return visitor.visitObject(self)
            else:
                return visitor.visitChildren(self)




    def object_(self):

        localctx = appgenParser.ObjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_object)
        try:
            self.state = 517
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 511
                self.database()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 512
                self.schema()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 513
                self.tableDecl()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 514
                self.mixin()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 515
                self.dbview()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 516
                self.dbfunc()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatabaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_database

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatabase" ):
                listener.enterDatabase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatabase" ):
                listener.exitDatabase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatabase" ):
                return visitor.visitDatabase(self)
            else:
                return visitor.visitChildren(self)




    def database(self):

        localctx = appgenParser.DatabaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_database)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 519
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PUBLIC(self):
            return self.getToken(appgenParser.PUBLIC, 0)

        def ident(self):
            return self.getTypedRuleContext(appgenParser.IdentContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_schema

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema" ):
                listener.enterSchema(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema" ):
                listener.exitSchema(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchema" ):
                return visitor.visitSchema(self)
            else:
                return visitor.visitChildren(self)




    def schema(self):

        localctx = appgenParser.SchemaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_schema)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 523
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [182]:
                self.state = 521
                self.match(appgenParser.PUBLIC)
                pass
            elif token in [130]:
                self.state = 522
                self.ident()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MixinContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MIXIN(self):
            return self.getToken(appgenParser.MIXIN, 0)

        def mixin_name(self):
            return self.getTypedRuleContext(appgenParser.Mixin_nameContext,0)


        def column_list(self):
            return self.getTypedRuleContext(appgenParser.Column_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_mixin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMixin" ):
                listener.enterMixin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMixin" ):
                listener.exitMixin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMixin" ):
                return visitor.visitMixin(self)
            else:
                return visitor.visitChildren(self)




    def mixin(self):

        localctx = appgenParser.MixinContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_mixin)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 525
            self.match(appgenParser.MIXIN)
            self.state = 526
            self.mixin_name()
            self.state = 527
            self.column_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mixin_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_mixin_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMixin_name" ):
                listener.enterMixin_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMixin_name" ):
                listener.exitMixin_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMixin_name" ):
                return visitor.visitMixin_name(self)
            else:
                return visitor.visitChildren(self)




    def mixin_name(self):

        localctx = appgenParser.Mixin_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_mixin_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 529
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.ColumnContext)
            else:
                return self.getTypedRuleContext(appgenParser.ColumnContext,i)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_column_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_list" ):
                listener.enterColumn_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_list" ):
                listener.exitColumn_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_list" ):
                return visitor.visitColumn_list(self)
            else:
                return visitor.visitChildren(self)




    def column_list(self):

        localctx = appgenParser.Column_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_column_list)
        self._la = 0 # Token type
        try:
            self.state = 547
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 531
                self.match(appgenParser.L_CURLY)
                self.state = 532
                self.column()
                self.state = 537
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,37,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 533
                        self.match(appgenParser.COMMA)
                        self.state = 534
                        self.column() 
                    self.state = 539
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

                self.state = 541
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==103:
                    self.state = 540
                    self.match(appgenParser.COMMA)


                self.state = 543
                self.match(appgenParser.R_CURLY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 545
                self.match(appgenParser.L_CURLY)
                self.state = 546
                self.match(appgenParser.R_CURLY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self):
            return self.getTypedRuleContext(appgenParser.Column_nameContext,0)


        def data_type(self):
            return self.getTypedRuleContext(appgenParser.Data_typeContext,0)


        def column_option_list(self):
            return self.getTypedRuleContext(appgenParser.Column_option_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_column

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn" ):
                listener.enterColumn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn" ):
                listener.exitColumn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn" ):
                return visitor.visitColumn(self)
            else:
                return visitor.visitChildren(self)




    def column(self):

        localctx = appgenParser.ColumnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_column)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 549
            self.column_name()
            self.state = 550
            self.data_type()
            self.state = 552
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==109:
                self.state = 551
                self.column_option_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_column_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_name" ):
                listener.enterColumn_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_name" ):
                listener.exitColumn_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_name" ):
                return visitor.visitColumn_name(self)
            else:
                return visitor.visitChildren(self)




    def column_name(self):

        localctx = appgenParser.Column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_option_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_SQUARE(self):
            return self.getToken(appgenParser.L_SQUARE, 0)

        def column_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Column_optionContext)
            else:
                return self.getTypedRuleContext(appgenParser.Column_optionContext,i)


        def R_SQUARE(self):
            return self.getToken(appgenParser.R_SQUARE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_column_option_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_option_list" ):
                listener.enterColumn_option_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_option_list" ):
                listener.exitColumn_option_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_option_list" ):
                return visitor.visitColumn_option_list(self)
            else:
                return visitor.visitChildren(self)




    def column_option_list(self):

        localctx = appgenParser.Column_option_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_column_option_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 556
            self.match(appgenParser.L_SQUARE)
            self.state = 557
            self.column_option()
            self.state = 562
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,41,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 558
                    self.match(appgenParser.COMMA)
                    self.state = 559
                    self.column_option() 
                self.state = 564
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

            self.state = 566
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 565
                self.match(appgenParser.COMMA)


            self.state = 568
            self.match(appgenParser.R_SQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Primary_keyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PK_SHORT(self):
            return self.getToken(appgenParser.PK_SHORT, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_primary_key

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary_key" ):
                listener.enterPrimary_key(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary_key" ):
                listener.exitPrimary_key(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimary_key" ):
                return visitor.visitPrimary_key(self)
            else:
                return visitor.visitChildren(self)




    def primary_key(self):

        localctx = appgenParser.Primary_keyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_primary_key)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 570
            _la = self._input.LA(1)
            if not(_la==183):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary_key(self):
            return self.getTypedRuleContext(appgenParser.Primary_keyContext,0)


        def DEFAULT(self):
            return self.getToken(appgenParser.DEFAULT, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def column_default(self):
            return self.getTypedRuleContext(appgenParser.Column_defaultContext,0)


        def CACHE(self):
            return self.getToken(appgenParser.CACHE, 0)

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def INT(self):
            return self.getToken(appgenParser.INT, 0)

        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def DEFAULT_EXPR(self):
            return self.getToken(appgenParser.DEFAULT_EXPR, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def INCR(self):
            return self.getToken(appgenParser.INCR, 0)

        def DECR(self):
            return self.getToken(appgenParser.DECR, 0)

        def unique(self):
            return self.getTypedRuleContext(appgenParser.UniqueContext,0)


        def NULLABLE(self):
            return self.getToken(appgenParser.NULLABLE, 0)

        def NOT_NULL(self):
            return self.getToken(appgenParser.NOT_NULL, 0)

        def ref_internal(self):
            return self.getTypedRuleContext(appgenParser.Ref_internalContext,0)


        def enum_internal(self):
            return self.getTypedRuleContext(appgenParser.Enum_internalContext,0)


        def MIN(self):
            return self.getToken(appgenParser.MIN, 0)

        def MAX(self):
            return self.getToken(appgenParser.MAX, 0)

        def CHECK(self):
            return self.getToken(appgenParser.CHECK, 0)

        def check_expr(self):
            return self.getTypedRuleContext(appgenParser.Check_exprContext,0)


        def display_method(self):
            return self.getTypedRuleContext(appgenParser.Display_methodContext,0)


        def note_option(self):
            return self.getTypedRuleContext(appgenParser.Note_optionContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_column_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_option" ):
                listener.enterColumn_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_option" ):
                listener.exitColumn_option(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_option" ):
                return visitor.visitColumn_option(self)
            else:
                return visitor.visitChildren(self)




    def column_option(self):

        localctx = appgenParser.Column_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_column_option)
        self._la = 0 # Token type
        try:
            self.state = 605
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [183]:
                self.enterOuterAlt(localctx, 1)
                self.state = 572
                self.primary_key()
                pass
            elif token in [178]:
                self.enterOuterAlt(localctx, 2)
                self.state = 573
                self.match(appgenParser.DEFAULT)
                self.state = 574
                self.match(appgenParser.EQ)
                self.state = 575
                self.column_default()
                pass
            elif token in [154]:
                self.enterOuterAlt(localctx, 3)
                self.state = 576
                self.match(appgenParser.CACHE)
                self.state = 580
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==107:
                    self.state = 577
                    self.match(appgenParser.L_PAR)
                    self.state = 578
                    self.match(appgenParser.INT)
                    self.state = 579
                    self.match(appgenParser.R_PAR)


                pass
            elif token in [179]:
                self.enterOuterAlt(localctx, 4)
                self.state = 582
                self.match(appgenParser.DEFAULT_EXPR)
                self.state = 583
                self.match(appgenParser.EQ)
                self.state = 584
                self.match(appgenParser.L_PAR)
                self.state = 585
                self.string()
                self.state = 586
                self.match(appgenParser.R_PAR)
                pass
            elif token in [144]:
                self.enterOuterAlt(localctx, 5)
                self.state = 588
                self.match(appgenParser.INCR)
                pass
            elif token in [145]:
                self.enterOuterAlt(localctx, 6)
                self.state = 589
                self.match(appgenParser.DECR)
                pass
            elif token in [153]:
                self.enterOuterAlt(localctx, 7)
                self.state = 590
                self.unique()
                pass
            elif token in [196]:
                self.enterOuterAlt(localctx, 8)
                self.state = 591
                self.match(appgenParser.NULLABLE)
                pass
            elif token in [146]:
                self.enterOuterAlt(localctx, 9)
                self.state = 592
                self.match(appgenParser.NOT_NULL)
                pass
            elif token in [161]:
                self.enterOuterAlt(localctx, 10)
                self.state = 593
                self.ref_internal()
                pass
            elif token in [174]:
                self.enterOuterAlt(localctx, 11)
                self.state = 594
                self.enum_internal()
                pass
            elif token in [176]:
                self.enterOuterAlt(localctx, 12)
                self.state = 595
                self.match(appgenParser.MIN)
                self.state = 596
                self.match(appgenParser.EQ)
                self.state = 597
                self.match(appgenParser.INT)
                pass
            elif token in [177]:
                self.enterOuterAlt(localctx, 13)
                self.state = 598
                self.match(appgenParser.MAX)
                self.state = 599
                self.match(appgenParser.EQ)
                self.state = 600
                self.match(appgenParser.INT)
                pass
            elif token in [155]:
                self.enterOuterAlt(localctx, 14)
                self.state = 601
                self.match(appgenParser.CHECK)
                self.state = 602
                self.check_expr()
                pass
            elif token in [150]:
                self.enterOuterAlt(localctx, 15)
                self.state = 603
                self.display_method()
                pass
            elif token in [159]:
                self.enterOuterAlt(localctx, 16)
                self.state = 604
                self.note_option()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Check_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_check_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheck_expr" ):
                listener.enterCheck_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheck_expr" ):
                listener.exitCheck_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCheck_expr" ):
                return visitor.visitCheck_expr(self)
            else:
                return visitor.visitChildren(self)




    def check_expr(self):

        localctx = appgenParser.Check_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_check_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 607
            self.match(appgenParser.L_PAR)
            self.state = 608
            self.string()
            self.state = 609
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varchar(self):
            return self.getTypedRuleContext(appgenParser.VarcharContext,0)


        def BLOB(self):
            return self.getToken(appgenParser.BLOB, 0)

        def FILE(self):
            return self.getToken(appgenParser.FILE, 0)

        def enum_name(self):
            return self.getTypedRuleContext(appgenParser.Enum_nameContext,0)


        def int_list(self):
            return self.getTypedRuleContext(appgenParser.Int_listContext,0)


        def data_type(self):
            return self.getTypedRuleContext(appgenParser.Data_typeContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_data_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_type" ):
                listener.enterData_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_type" ):
                listener.exitData_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitData_type" ):
                return visitor.visitData_type(self)
            else:
                return visitor.visitChildren(self)




    def data_type(self):

        localctx = appgenParser.Data_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_data_type)
        try:
            self.state = 671
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 611
                self.match(appgenParser.T__1)
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 612
                self.match(appgenParser.T__2)
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 3)
                self.state = 613
                self.match(appgenParser.T__3)
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 4)
                self.state = 614
                self.match(appgenParser.T__4)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 5)
                self.state = 615
                self.match(appgenParser.T__5)
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 6)
                self.state = 616
                self.match(appgenParser.T__6)
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 7)
                self.state = 617
                self.match(appgenParser.T__7)
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 8)
                self.state = 618
                self.match(appgenParser.T__8)
                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 9)
                self.state = 619
                self.match(appgenParser.T__9)
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 10)
                self.state = 620
                self.match(appgenParser.T__10)
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 11)
                self.state = 621
                self.match(appgenParser.T__11)
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 12)
                self.state = 622
                self.match(appgenParser.T__12)
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 13)
                self.state = 623
                self.match(appgenParser.T__13)
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 14)
                self.state = 624
                self.match(appgenParser.T__14)
                pass
            elif token in [158]:
                self.enterOuterAlt(localctx, 15)
                self.state = 625
                self.varchar()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 16)
                self.state = 626
                self.match(appgenParser.T__15)
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 17)
                self.state = 627
                self.match(appgenParser.T__16)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 18)
                self.state = 628
                self.match(appgenParser.T__17)
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 19)
                self.state = 629
                self.match(appgenParser.T__18)
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 20)
                self.state = 630
                self.match(appgenParser.T__19)
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 21)
                self.state = 631
                self.match(appgenParser.T__20)
                pass
            elif token in [180]:
                self.enterOuterAlt(localctx, 22)
                self.state = 632
                self.match(appgenParser.BLOB)
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 23)
                self.state = 633
                self.match(appgenParser.T__21)
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 24)
                self.state = 634
                self.match(appgenParser.T__22)
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 25)
                self.state = 635
                self.match(appgenParser.T__23)
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 26)
                self.state = 636
                self.match(appgenParser.T__24)
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 27)
                self.state = 637
                self.match(appgenParser.T__25)
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 28)
                self.state = 638
                self.match(appgenParser.T__26)
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 29)
                self.state = 639
                self.match(appgenParser.T__27)
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 30)
                self.state = 640
                self.match(appgenParser.T__28)
                pass
            elif token in [30]:
                self.enterOuterAlt(localctx, 31)
                self.state = 641
                self.match(appgenParser.T__29)
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 32)
                self.state = 642
                self.match(appgenParser.T__30)
                pass
            elif token in [32]:
                self.enterOuterAlt(localctx, 33)
                self.state = 643
                self.match(appgenParser.T__31)
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 34)
                self.state = 644
                self.match(appgenParser.T__32)
                pass
            elif token in [34]:
                self.enterOuterAlt(localctx, 35)
                self.state = 645
                self.match(appgenParser.T__33)
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 36)
                self.state = 646
                self.match(appgenParser.T__34)
                pass
            elif token in [36]:
                self.enterOuterAlt(localctx, 37)
                self.state = 647
                self.match(appgenParser.T__35)
                pass
            elif token in [37]:
                self.enterOuterAlt(localctx, 38)
                self.state = 648
                self.match(appgenParser.T__36)
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 39)
                self.state = 649
                self.match(appgenParser.T__37)
                pass
            elif token in [39]:
                self.enterOuterAlt(localctx, 40)
                self.state = 650
                self.match(appgenParser.T__38)
                pass
            elif token in [40]:
                self.enterOuterAlt(localctx, 41)
                self.state = 651
                self.match(appgenParser.T__39)
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 42)
                self.state = 652
                self.match(appgenParser.T__40)
                pass
            elif token in [42]:
                self.enterOuterAlt(localctx, 43)
                self.state = 653
                self.match(appgenParser.T__41)
                pass
            elif token in [43]:
                self.enterOuterAlt(localctx, 44)
                self.state = 654
                self.match(appgenParser.T__42)
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 45)
                self.state = 655
                self.match(appgenParser.T__43)
                pass
            elif token in [45]:
                self.enterOuterAlt(localctx, 46)
                self.state = 656
                self.match(appgenParser.T__44)
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 47)
                self.state = 657
                self.match(appgenParser.T__45)
                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 48)
                self.state = 658
                self.match(appgenParser.T__46)
                pass
            elif token in [48]:
                self.enterOuterAlt(localctx, 49)
                self.state = 659
                self.match(appgenParser.T__47)
                pass
            elif token in [103, 109, 112]:
                self.enterOuterAlt(localctx, 50)

                pass
            elif token in [181]:
                self.enterOuterAlt(localctx, 51)
                self.state = 661
                self.match(appgenParser.FILE)
                pass
            elif token in [49]:
                self.enterOuterAlt(localctx, 52)
                self.state = 662
                self.match(appgenParser.T__48)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 53)
                self.state = 663
                self.match(appgenParser.T__49)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 54)
                self.state = 664
                self.match(appgenParser.T__50)
                pass
            elif token in [130]:
                self.enterOuterAlt(localctx, 55)
                self.state = 665
                self.enum_name()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 56)
                self.state = 666
                self.match(appgenParser.T__51)
                self.state = 667
                self.int_list()
                self.state = 668
                self.match(appgenParser.T__52)
                self.state = 669
                self.data_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_referenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self):
            return self.getTypedRuleContext(appgenParser.Column_nameContext,0)


        def table_reference(self):
            return self.getTypedRuleContext(appgenParser.Table_referenceContext,0)


        def DOT(self):
            return self.getToken(appgenParser.DOT, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_column_reference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_reference" ):
                listener.enterColumn_reference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_reference" ):
                listener.exitColumn_reference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_reference" ):
                return visitor.visitColumn_reference(self)
            else:
                return visitor.visitChildren(self)




    def column_reference(self):

        localctx = appgenParser.Column_referenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_column_reference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 676
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.state = 673
                self.table_reference()
                self.state = 674
                self.match(appgenParser.DOT)


            self.state = 678
            self.column_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_referenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(appgenParser.Table_nameContext,0)


        def schema(self):
            return self.getTypedRuleContext(appgenParser.SchemaContext,0)


        def DOT(self):
            return self.getToken(appgenParser.DOT, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_table_reference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_reference" ):
                listener.enterTable_reference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_reference" ):
                listener.exitTable_reference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_reference" ):
                return visitor.visitTable_reference(self)
            else:
                return visitor.visitChildren(self)




    def table_reference(self):

        localctx = appgenParser.Table_referenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_table_reference)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 683
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 680
                self.schema()
                self.state = 681
                self.match(appgenParser.DOT)


            self.state = 685
            self.table_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_defaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(appgenParser.NUMBER, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def BOOL(self):
            return self.getToken(appgenParser.BOOL, 0)

        def NOW(self):
            return self.getToken(appgenParser.NOW, 0)

        def TODAY(self):
            return self.getToken(appgenParser.TODAY, 0)

        def TOMORROW(self):
            return self.getToken(appgenParser.TOMORROW, 0)

        def NULL(self):
            return self.getToken(appgenParser.NULL, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_column_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_default" ):
                listener.enterColumn_default(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_default" ):
                listener.exitColumn_default(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_default" ):
                return visitor.visitColumn_default(self)
            else:
                return visitor.visitChildren(self)




    def column_default(self):

        localctx = appgenParser.Column_defaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_column_default)
        try:
            self.state = 696
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [133]:
                self.enterOuterAlt(localctx, 1)
                self.state = 687
                self.match(appgenParser.NUMBER)
                pass
            elif token in [131]:
                self.enterOuterAlt(localctx, 2)
                self.state = 688
                self.string()
                pass
            elif token in [137]:
                self.enterOuterAlt(localctx, 3)
                self.state = 689
                self.match(appgenParser.BOOL)
                pass
            elif token in [197]:
                self.enterOuterAlt(localctx, 4)
                self.state = 690
                self.match(appgenParser.NOW)
                pass
            elif token in [198]:
                self.enterOuterAlt(localctx, 5)
                self.state = 691
                self.match(appgenParser.TODAY)
                pass
            elif token in [200]:
                self.enterOuterAlt(localctx, 6)
                self.state = 692
                self.match(appgenParser.TOMORROW)
                pass
            elif token in [54]:
                self.enterOuterAlt(localctx, 7)
                self.state = 693
                self.match(appgenParser.T__53)
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 8)
                self.state = 694
                self.match(appgenParser.T__54)
                pass
            elif token in [147]:
                self.enterOuterAlt(localctx, 9)
                self.state = 695
                self.match(appgenParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enum_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_enum_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_name" ):
                listener.enterEnum_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_name" ):
                listener.exitEnum_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_name" ):
                return visitor.visitEnum_name(self)
            else:
                return visitor.visitChildren(self)




    def enum_name(self):

        localctx = appgenParser.Enum_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_enum_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enum_internalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM(self):
            return self.getToken(appgenParser.ENUM, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def enum_list(self):
            return self.getTypedRuleContext(appgenParser.Enum_listContext,0)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_enum_internal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_internal" ):
                listener.enterEnum_internal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_internal" ):
                listener.exitEnum_internal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_internal" ):
                return visitor.visitEnum_internal(self)
            else:
                return visitor.visitChildren(self)




    def enum_internal(self):

        localctx = appgenParser.Enum_internalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_enum_internal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700
            self.match(appgenParser.ENUM)
            self.state = 701
            self.match(appgenParser.EQ)
            self.state = 702
            self.match(appgenParser.L_CURLY)
            self.state = 703
            self.enum_list()
            self.state = 704
            self.match(appgenParser.R_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enum_outContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM(self):
            return self.getToken(appgenParser.ENUM, 0)

        def enum_name(self):
            return self.getTypedRuleContext(appgenParser.Enum_nameContext,0)


        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def enum_list(self):
            return self.getTypedRuleContext(appgenParser.Enum_listContext,0)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_enum_out

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_out" ):
                listener.enterEnum_out(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_out" ):
                listener.exitEnum_out(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_out" ):
                return visitor.visitEnum_out(self)
            else:
                return visitor.visitChildren(self)




    def enum_out(self):

        localctx = appgenParser.Enum_outContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_enum_out)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self.match(appgenParser.ENUM)
            self.state = 707
            self.enum_name()
            self.state = 708
            self.match(appgenParser.L_CURLY)
            self.state = 709
            self.enum_list()
            self.state = 710
            self.match(appgenParser.R_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enum_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enum_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Enum_itemContext)
            else:
                return self.getTypedRuleContext(appgenParser.Enum_itemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_enum_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_list" ):
                listener.enterEnum_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_list" ):
                listener.exitEnum_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_list" ):
                return visitor.visitEnum_list(self)
            else:
                return visitor.visitChildren(self)




    def enum_list(self):

        localctx = appgenParser.Enum_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_enum_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 712
            self.enum_item()
            self.state = 717
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,49,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 713
                    self.match(appgenParser.COMMA)
                    self.state = 714
                    self.enum_item() 
                self.state = 719
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

            self.state = 721
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 720
                self.match(appgenParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enum_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enum_value(self):
            return self.getTypedRuleContext(appgenParser.Enum_valueContext,0)


        def enum_idx(self):
            return self.getTypedRuleContext(appgenParser.Enum_idxContext,0)


        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def L_SQUARE(self):
            return self.getToken(appgenParser.L_SQUARE, 0)

        def note_option(self):
            return self.getTypedRuleContext(appgenParser.Note_optionContext,0)


        def R_SQUARE(self):
            return self.getToken(appgenParser.R_SQUARE, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_enum_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_item" ):
                listener.enterEnum_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_item" ):
                listener.exitEnum_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_item" ):
                return visitor.visitEnum_item(self)
            else:
                return visitor.visitChildren(self)




    def enum_item(self):

        localctx = appgenParser.Enum_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_enum_item)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 726
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==132:
                self.state = 723
                self.enum_idx()
                self.state = 724
                self.match(appgenParser.EQ)


            self.state = 728
            self.enum_value()
            self.state = 733
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==109:
                self.state = 729
                self.match(appgenParser.L_SQUARE)
                self.state = 730
                self.note_option()
                self.state = 731
                self.match(appgenParser.R_SQUARE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enum_idxContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def int_(self):
            return self.getTypedRuleContext(appgenParser.IntContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_enum_idx

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_idx" ):
                listener.enterEnum_idx(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_idx" ):
                listener.exitEnum_idx(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_idx" ):
                return visitor.visitEnum_idx(self)
            else:
                return visitor.visitChildren(self)




    def enum_idx(self):

        localctx = appgenParser.Enum_idxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_enum_idx)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 735
            self.int_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enum_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_enum_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_value" ):
                listener.enterEnum_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_value" ):
                listener.exitEnum_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_value" ):
                return visitor.visitEnum_value(self)
            else:
                return visitor.visitChildren(self)




    def enum_value(self):

        localctx = appgenParser.Enum_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_enum_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 737
            self.string()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Display_methodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISPLAY(self):
            return self.getToken(appgenParser.DISPLAY, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def option_list(self):
            return self.getTypedRuleContext(appgenParser.Option_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_display_method

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisplay_method" ):
                listener.enterDisplay_method(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisplay_method" ):
                listener.exitDisplay_method(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisplay_method" ):
                return visitor.visitDisplay_method(self)
            else:
                return visitor.visitChildren(self)




    def display_method(self):

        localctx = appgenParser.Display_methodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_display_method)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 739
            self.match(appgenParser.DISPLAY)
            self.state = 740
            self.match(appgenParser.EQ)
            self.state = 741
            self.option_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Note_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOTE(self):
            return self.getToken(appgenParser.NOTE, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def note_value(self):
            return self.getTypedRuleContext(appgenParser.Note_valueContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_note_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNote_option" ):
                listener.enterNote_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNote_option" ):
                listener.exitNote_option(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNote_option" ):
                return visitor.visitNote_option(self)
            else:
                return visitor.visitChildren(self)




    def note_option(self):

        localctx = appgenParser.Note_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_note_option)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 743
            self.match(appgenParser.NOTE)
            self.state = 744
            self.match(appgenParser.EQ)
            self.state = 745
            self.note_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Note_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_note_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNote_value" ):
                listener.enterNote_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNote_value" ):
                listener.exitNote_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNote_value" ):
                return visitor.visitNote_value(self)
            else:
                return visitor.visitChildren(self)




    def note_value(self):

        localctx = appgenParser.Note_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_note_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 747
            self.string()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarcharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARCHAR(self):
            return self.getToken(appgenParser.VARCHAR, 0)

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def INT(self):
            return self.getToken(appgenParser.INT, 0)

        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_varchar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarchar" ):
                listener.enterVarchar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarchar" ):
                listener.exitVarchar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarchar" ):
                return visitor.visitVarchar(self)
            else:
                return visitor.visitChildren(self)




    def varchar(self):

        localctx = appgenParser.VarcharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_varchar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 749
            self.match(appgenParser.VARCHAR)
            self.state = 750
            self.match(appgenParser.L_PAR)
            self.state = 751
            self.match(appgenParser.INT)
            self.state = 752
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLE(self):
            return self.getToken(appgenParser.TABLE, 0)

        def table_name(self):
            return self.getTypedRuleContext(appgenParser.Table_nameContext,0)


        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def column_list(self):
            return self.getTypedRuleContext(appgenParser.Column_listContext,0)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def mixin_list(self):
            return self.getTypedRuleContext(appgenParser.Mixin_listContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def index_int(self):
            return self.getTypedRuleContext(appgenParser.Index_intContext,0)


        def view_s_spec(self):
            return self.getTypedRuleContext(appgenParser.View_s_specContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_tableDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableDecl" ):
                listener.enterTableDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableDecl" ):
                listener.exitTableDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableDecl" ):
                return visitor.visitTableDecl(self)
            else:
                return visitor.visitChildren(self)




    def tableDecl(self):

        localctx = appgenParser.TableDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_tableDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 754
            self.match(appgenParser.TABLE)
            self.state = 755
            self.table_name()
            self.state = 760
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==107:
                self.state = 756
                self.match(appgenParser.L_PAR)
                self.state = 757
                self.mixin_list()
                self.state = 758
                self.match(appgenParser.R_PAR)


            self.state = 762
            self.match(appgenParser.L_CURLY)
            self.state = 763
            self.column_list()
            self.state = 765
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==63:
                self.state = 764
                self.index_int()


            self.state = 768
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64:
                self.state = 767
                self.view_s_spec()


            self.state = 770
            self.match(appgenParser.R_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mixin_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mixin_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Mixin_nameContext)
            else:
                return self.getTypedRuleContext(appgenParser.Mixin_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_mixin_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMixin_list" ):
                listener.enterMixin_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMixin_list" ):
                listener.exitMixin_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMixin_list" ):
                return visitor.visitMixin_list(self)
            else:
                return visitor.visitChildren(self)




    def mixin_list(self):

        localctx = appgenParser.Mixin_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_mixin_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 773
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==130:
                self.state = 772
                self.mixin_name()


            self.state = 779
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==103:
                self.state = 775
                self.match(appgenParser.COMMA)
                self.state = 776
                self.mixin_name()
                self.state = 781
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_table_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_name" ):
                listener.enterTable_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_name" ):
                listener.exitTable_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_name" ):
                return visitor.visitTable_name(self)
            else:
                return visitor.visitChildren(self)




    def table_name(self):

        localctx = appgenParser.Table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DbviewContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DBVIEW(self):
            return self.getToken(appgenParser.DBVIEW, 0)

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def db_join(self):
            return self.getTypedRuleContext(appgenParser.Db_joinContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_dbview

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDbview" ):
                listener.enterDbview(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDbview" ):
                listener.exitDbview(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDbview" ):
                return visitor.visitDbview(self)
            else:
                return visitor.visitChildren(self)




    def dbview(self):

        localctx = appgenParser.DbviewContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_dbview)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 784
            self.match(appgenParser.DBVIEW)
            self.state = 785
            self.match(appgenParser.EQ)
            self.state = 786
            self.match(appgenParser.L_PAR)
            self.state = 787
            self.db_join()
            self.state = 788
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Db_joinContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_reference(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Column_referenceContext)
            else:
                return self.getTypedRuleContext(appgenParser.Column_referenceContext,i)


        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_db_join

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDb_join" ):
                listener.enterDb_join(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDb_join" ):
                listener.exitDb_join(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDb_join" ):
                return visitor.visitDb_join(self)
            else:
                return visitor.visitChildren(self)




    def db_join(self):

        localctx = appgenParser.Db_joinContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_db_join)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 790
            self.column_reference()
            self.state = 791
            self.match(appgenParser.EQ)
            self.state = 792
            self.column_reference()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ref_internalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REF(self):
            return self.getToken(appgenParser.REF, 0)

        def COLON(self):
            return self.getToken(appgenParser.COLON, 0)

        def ref_type(self):
            return self.getTypedRuleContext(appgenParser.Ref_typeContext,0)


        def table_name(self):
            return self.getTypedRuleContext(appgenParser.Table_nameContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.DOT)
            else:
                return self.getToken(appgenParser.DOT, i)

        def column_name(self):
            return self.getTypedRuleContext(appgenParser.Column_nameContext,0)


        def ref_name(self):
            return self.getTypedRuleContext(appgenParser.Ref_nameContext,0)


        def schema(self):
            return self.getTypedRuleContext(appgenParser.SchemaContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_ref_internal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRef_internal" ):
                listener.enterRef_internal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRef_internal" ):
                listener.exitRef_internal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRef_internal" ):
                return visitor.visitRef_internal(self)
            else:
                return visitor.visitChildren(self)




    def ref_internal(self):

        localctx = appgenParser.Ref_internalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_ref_internal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 794
            self.match(appgenParser.REF)
            self.state = 796
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==130:
                self.state = 795
                self.ref_name()


            self.state = 798
            self.match(appgenParser.COLON)
            self.state = 799
            self.ref_type()
            self.state = 803
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 800
                self.schema()
                self.state = 801
                self.match(appgenParser.DOT)


            self.state = 805
            self.table_name()
            self.state = 806
            self.match(appgenParser.DOT)
            self.state = 807
            self.column_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ext_refContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REF(self):
            return self.getToken(appgenParser.REF, 0)

        def COLON(self):
            return self.getToken(appgenParser.COLON, 0)

        def table_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Table_nameContext)
            else:
                return self.getTypedRuleContext(appgenParser.Table_nameContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.DOT)
            else:
                return self.getToken(appgenParser.DOT, i)

        def ref_type(self):
            return self.getTypedRuleContext(appgenParser.Ref_typeContext,0)


        def ref_name(self):
            return self.getTypedRuleContext(appgenParser.Ref_nameContext,0)


        def schema(self):
            return self.getTypedRuleContext(appgenParser.SchemaContext,0)


        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(appgenParser.Column_nameContext,i)


        def getRuleIndex(self):
            return appgenParser.RULE_ext_ref

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExt_ref" ):
                listener.enterExt_ref(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExt_ref" ):
                listener.exitExt_ref(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExt_ref" ):
                return visitor.visitExt_ref(self)
            else:
                return visitor.visitChildren(self)




    def ext_ref(self):

        localctx = appgenParser.Ext_refContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_ext_ref)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 809
            self.match(appgenParser.REF)
            self.state = 811
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==130:
                self.state = 810
                self.ref_name()


            self.state = 813
            self.match(appgenParser.COLON)
            self.state = 817
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
            if la_ == 1:
                self.state = 814
                self.schema()
                self.state = 815
                self.match(appgenParser.DOT)


            self.state = 819
            self.table_name()
            self.state = 820
            self.match(appgenParser.DOT)
            self.state = 822 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 821
                self.column_name()
                self.state = 824 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==130):
                    break

            self.state = 826
            self.ref_type()
            self.state = 827
            self.table_name()
            self.state = 828
            self.match(appgenParser.DOT)
            self.state = 830 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 829
                    self.column_name()

                else:
                    raise NoViableAltException(self)
                self.state = 832 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,63,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ref_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_ref_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRef_name" ):
                listener.enterRef_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRef_name" ):
                listener.exitRef_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRef_name" ):
                return visitor.visitRef_name(self)
            else:
                return visitor.visitChildren(self)




    def ref_name(self):

        localctx = appgenParser.Ref_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_ref_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 834
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ref_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def oneToOne(self):
            return self.getTypedRuleContext(appgenParser.OneToOneContext,0)


        def oneToMany(self):
            return self.getTypedRuleContext(appgenParser.OneToManyContext,0)


        def manyToOne(self):
            return self.getTypedRuleContext(appgenParser.ManyToOneContext,0)


        def manyToMany(self):
            return self.getTypedRuleContext(appgenParser.ManyToManyContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_ref_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRef_type" ):
                listener.enterRef_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRef_type" ):
                listener.exitRef_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRef_type" ):
                return visitor.visitRef_type(self)
            else:
                return visitor.visitChildren(self)




    def ref_type(self):

        localctx = appgenParser.Ref_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_ref_type)
        try:
            self.state = 840
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [115]:
                self.enterOuterAlt(localctx, 1)
                self.state = 836
                self.oneToOne()
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 2)
                self.state = 837
                self.oneToMany()
                pass
            elif token in [119]:
                self.enterOuterAlt(localctx, 3)
                self.state = 838
                self.manyToOne()
                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 4)
                self.state = 839
                self.manyToMany()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OneToOneContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUB(self):
            return self.getToken(appgenParser.SUB, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_oneToOne

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOneToOne" ):
                listener.enterOneToOne(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOneToOne" ):
                listener.exitOneToOne(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOneToOne" ):
                return visitor.visitOneToOne(self)
            else:
                return visitor.visitChildren(self)




    def oneToOne(self):

        localctx = appgenParser.OneToOneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_oneToOne)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 842
            self.match(appgenParser.SUB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OneToManyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(appgenParser.LT, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_oneToMany

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOneToMany" ):
                listener.enterOneToMany(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOneToMany" ):
                listener.exitOneToMany(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOneToMany" ):
                return visitor.visitOneToMany(self)
            else:
                return visitor.visitChildren(self)




    def oneToMany(self):

        localctx = appgenParser.OneToManyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_oneToMany)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 844
            self.match(appgenParser.LT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ManyToOneContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT(self):
            return self.getToken(appgenParser.GT, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_manyToOne

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterManyToOne" ):
                listener.enterManyToOne(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitManyToOne" ):
                listener.exitManyToOne(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitManyToOne" ):
                return visitor.visitManyToOne(self)
            else:
                return visitor.visitChildren(self)




    def manyToOne(self):

        localctx = appgenParser.ManyToOneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_manyToOne)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 846
            self.match(appgenParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ManyToManyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def M2M(self):
            return self.getToken(appgenParser.M2M, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_manyToMany

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterManyToMany" ):
                listener.enterManyToMany(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitManyToMany" ):
                listener.exitManyToMany(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitManyToMany" ):
                return visitor.visitManyToMany(self)
            else:
                return visitor.visitChildren(self)




    def manyToMany(self):

        localctx = appgenParser.ManyToManyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_manyToMany)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 848
            self.match(appgenParser.M2M)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_extContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(appgenParser.Table_nameContext,0)


        def L_SQUARE(self):
            return self.getToken(appgenParser.L_SQUARE, 0)

        def column_names(self):
            return self.getTypedRuleContext(appgenParser.Column_namesContext,0)


        def R_SQUARE(self):
            return self.getToken(appgenParser.R_SQUARE, 0)

        def index_name(self):
            return self.getTypedRuleContext(appgenParser.Index_nameContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_index_ext

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_ext" ):
                listener.enterIndex_ext(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_ext" ):
                listener.exitIndex_ext(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_ext" ):
                return visitor.visitIndex_ext(self)
            else:
                return visitor.visitChildren(self)




    def index_ext(self):

        localctx = appgenParser.Index_extContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_index_ext)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 850
            self.match(appgenParser.T__55)
            self.state = 852
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==130:
                self.state = 851
                self.index_name()


            self.state = 854
            self.match(appgenParser.T__56)
            self.state = 855
            self.table_name()
            self.state = 856
            self.match(appgenParser.L_SQUARE)
            self.state = 857
            self.column_names()
            self.state = 858
            self.match(appgenParser.R_SQUARE)
            self.state = 861
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==58:
                self.state = 859
                self.match(appgenParser.T__57)
                self.state = 860
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8646911284551352320) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def index_item_list(self):
            return self.getTypedRuleContext(appgenParser.Index_item_listContext,0)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_index_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_int" ):
                listener.enterIndex_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_int" ):
                listener.exitIndex_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_int" ):
                return visitor.visitIndex_int(self)
            else:
                return visitor.visitChildren(self)




    def index_int(self):

        localctx = appgenParser.Index_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_index_int)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 863
            self.match(appgenParser.T__62)
            self.state = 864
            self.match(appgenParser.EQ)
            self.state = 865
            self.match(appgenParser.L_CURLY)
            self.state = 866
            self.index_item_list()
            self.state = 867
            self.match(appgenParser.R_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_item_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def index_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Index_itemContext)
            else:
                return self.getTypedRuleContext(appgenParser.Index_itemContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_index_item_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_item_list" ):
                listener.enterIndex_item_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_item_list" ):
                listener.exitIndex_item_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_item_list" ):
                return visitor.visitIndex_item_list(self)
            else:
                return visitor.visitChildren(self)




    def index_item_list(self):

        localctx = appgenParser.Index_item_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_index_item_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 869
            self.index_item()
            self.state = 874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==103:
                self.state = 870
                self.match(appgenParser.COMMA)
                self.state = 871
                self.index_item()
                self.state = 876
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_SQUARE(self):
            return self.getToken(appgenParser.L_SQUARE, 0)

        def column_names(self):
            return self.getTypedRuleContext(appgenParser.Column_namesContext,0)


        def R_SQUARE(self):
            return self.getToken(appgenParser.R_SQUARE, 0)

        def index_name(self):
            return self.getTypedRuleContext(appgenParser.Index_nameContext,0)


        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_index_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_item" ):
                listener.enterIndex_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_item" ):
                listener.exitIndex_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_item" ):
                return visitor.visitIndex_item(self)
            else:
                return visitor.visitChildren(self)




    def index_item(self):

        localctx = appgenParser.Index_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_index_item)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 880
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==130:
                self.state = 877
                self.index_name()
                self.state = 878
                self.match(appgenParser.EQ)


            self.state = 882
            self.match(appgenParser.L_SQUARE)
            self.state = 883
            self.column_names()
            self.state = 884
            self.match(appgenParser.R_SQUARE)
            self.state = 887
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==58:
                self.state = 885
                self.match(appgenParser.T__57)
                self.state = 886
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8646911284551352320) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_namesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(appgenParser.Column_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_column_names

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_names" ):
                listener.enterColumn_names(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_names" ):
                listener.exitColumn_names(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_names" ):
                return visitor.visitColumn_names(self)
            else:
                return visitor.visitChildren(self)




    def column_names(self):

        localctx = appgenParser.Column_namesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_column_names)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 889
            self.column_name()
            self.state = 894
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,70,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 890
                    self.match(appgenParser.COMMA)
                    self.state = 891
                    self.column_name() 
                self.state = 896
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,70,self._ctx)

            self.state = 898
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 897
                self.match(appgenParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_index_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_name" ):
                listener.enterIndex_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_name" ):
                listener.exitIndex_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_name" ):
                return visitor.visitIndex_name(self)
            else:
                return visitor.visitChildren(self)




    def index_name(self):

        localctx = appgenParser.Index_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_index_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 900
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class View_s_specContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def view_spec_list(self):
            return self.getTypedRuleContext(appgenParser.View_spec_listContext,0)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_view_s_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterView_s_spec" ):
                listener.enterView_s_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitView_s_spec" ):
                listener.exitView_s_spec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitView_s_spec" ):
                return visitor.visitView_s_spec(self)
            else:
                return visitor.visitChildren(self)




    def view_s_spec(self):

        localctx = appgenParser.View_s_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_view_s_spec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 902
            self.match(appgenParser.T__63)
            self.state = 903
            self.match(appgenParser.EQ)
            self.state = 904
            self.match(appgenParser.L_CURLY)
            self.state = 905
            self.view_spec_list()
            self.state = 906
            self.match(appgenParser.R_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class View_spec_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def view_spec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.View_specContext)
            else:
                return self.getTypedRuleContext(appgenParser.View_specContext,i)


        def COMMA(self):
            return self.getToken(appgenParser.COMMA, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_view_spec_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterView_spec_list" ):
                listener.enterView_spec_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitView_spec_list" ):
                listener.exitView_spec_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitView_spec_list" ):
                return visitor.visitView_spec_list(self)
            else:
                return visitor.visitChildren(self)




    def view_spec_list(self):

        localctx = appgenParser.View_spec_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_view_spec_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 908
            self.view_spec()

            self.state = 909
            self.match(appgenParser.COMMA)
            self.state = 910
            self.view_spec()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class View_specContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def view_type(self):
            return self.getTypedRuleContext(appgenParser.View_typeContext,0)


        def COLON(self):
            return self.getToken(appgenParser.COLON, 0)

        def L_CURLY(self):
            return self.getToken(appgenParser.L_CURLY, 0)

        def view_spec_options(self):
            return self.getTypedRuleContext(appgenParser.View_spec_optionsContext,0)


        def R_CURLY(self):
            return self.getToken(appgenParser.R_CURLY, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_view_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterView_spec" ):
                listener.enterView_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitView_spec" ):
                listener.exitView_spec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitView_spec" ):
                return visitor.visitView_spec(self)
            else:
                return visitor.visitChildren(self)




    def view_spec(self):

        localctx = appgenParser.View_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_view_spec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 912
            self.view_type()
            self.state = 913
            self.match(appgenParser.COLON)
            self.state = 914
            self.match(appgenParser.L_CURLY)
            self.state = 915
            self.view_spec_options()
            self.state = 916
            self.match(appgenParser.R_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class View_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return appgenParser.RULE_view_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterView_type" ):
                listener.enterView_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitView_type" ):
                listener.exitView_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitView_type" ):
                return visitor.visitView_type(self)
            else:
                return visitor.visitChildren(self)




    def view_type(self):

        localctx = appgenParser.View_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_view_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 918
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class View_spec_optionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def L_SQUARE(self):
            return self.getToken(appgenParser.L_SQUARE, 0)

        def column_names(self):
            return self.getTypedRuleContext(appgenParser.Column_namesContext,0)


        def R_SQUARE(self):
            return self.getToken(appgenParser.R_SQUARE, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_view_spec_options

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterView_spec_options" ):
                listener.enterView_spec_options(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitView_spec_options" ):
                listener.exitView_spec_options(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitView_spec_options" ):
                return visitor.visitView_spec_options(self)
            else:
                return visitor.visitChildren(self)




    def view_spec_options(self):

        localctx = appgenParser.View_spec_optionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_view_spec_options)
        self._la = 0 # Token type
        try:
            self.state = 932
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [70, 71]:
                self.enterOuterAlt(localctx, 1)
                self.state = 920
                _la = self._input.LA(1)
                if not(_la==70 or _la==71):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 921
                self.match(appgenParser.EQ)
                self.state = 922
                self.match(appgenParser.L_SQUARE)
                self.state = 923
                self.column_names()
                self.state = 924
                self.match(appgenParser.R_SQUARE)
                pass
            elif token in [72, 73]:
                self.enterOuterAlt(localctx, 2)
                self.state = 926
                _la = self._input.LA(1)
                if not(_la==72 or _la==73):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 927
                self.match(appgenParser.EQ)
                self.state = 928
                self.match(appgenParser.L_SQUARE)
                self.state = 929
                self.column_names()
                self.state = 930
                self.match(appgenParser.R_SQUARE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Business_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rule_name(self):
            return self.getTypedRuleContext(appgenParser.Rule_nameContext,0)


        def COLON(self):
            return self.getToken(appgenParser.COLON, 0)

        def businessRule(self):
            return self.getTypedRuleContext(appgenParser.BusinessRuleContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_business_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBusiness_rule" ):
                listener.enterBusiness_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBusiness_rule" ):
                listener.exitBusiness_rule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBusiness_rule" ):
                return visitor.visitBusiness_rule(self)
            else:
                return visitor.visitChildren(self)




    def business_rule(self):

        localctx = appgenParser.Business_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_business_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 934
            self.match(appgenParser.T__73)
            self.state = 935
            self.rule_name()
            self.state = 936
            self.match(appgenParser.COLON)
            self.state = 937
            self.businessRule()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BusinessRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifExpr(self):
            return self.getTypedRuleContext(appgenParser.IfExprContext,0)


        def actionExpr(self):
            return self.getTypedRuleContext(appgenParser.ActionExprContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_businessRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBusinessRule" ):
                listener.enterBusinessRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBusinessRule" ):
                listener.exitBusinessRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBusinessRule" ):
                return visitor.visitBusinessRule(self)
            else:
                return visitor.visitChildren(self)




    def businessRule(self):

        localctx = appgenParser.BusinessRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_businessRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 939
            self.ifExpr()
            self.state = 940
            self.match(appgenParser.T__74)
            self.state = 941
            self.actionExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.L_PAR)
            else:
                return self.getToken(appgenParser.L_PAR, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.ExprContext)
            else:
                return self.getTypedRuleContext(appgenParser.ExprContext,i)


        def R_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.R_PAR)
            else:
                return self.getToken(appgenParser.R_PAR, i)

        def getRuleIndex(self):
            return appgenParser.RULE_ifExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExpr" ):
                listener.enterIfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExpr" ):
                listener.exitIfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfExpr" ):
                return visitor.visitIfExpr(self)
            else:
                return visitor.visitChildren(self)




    def ifExpr(self):

        localctx = appgenParser.IfExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_ifExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 943
            _la = self._input.LA(1)
            if not(_la==57 or _la==76):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 944
            self.match(appgenParser.L_PAR)
            self.state = 945
            self.expr(0)
            self.state = 946
            self.match(appgenParser.R_PAR)
            self.state = 952
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==77:
                self.state = 947
                self.match(appgenParser.T__76)
                self.state = 948
                self.match(appgenParser.L_PAR)
                self.state = 949
                self.expr(0)
                self.state = 950
                self.match(appgenParser.R_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rule_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_rule_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRule_name" ):
                listener.enterRule_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRule_name" ):
                listener.exitRule_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRule_name" ):
                return visitor.visitRule_name(self)
            else:
                return visitor.visitChildren(self)




    def rule_name(self):

        localctx = appgenParser.Rule_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_rule_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 954
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def python_code(self):
            return self.getTypedRuleContext(appgenParser.Python_codeContext,0)


        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def sms(self):
            return self.getTypedRuleContext(appgenParser.SmsContext,0)


        def notify(self):
            return self.getTypedRuleContext(appgenParser.NotifyContext,0)


        def search(self):
            return self.getTypedRuleContext(appgenParser.SearchContext,0)


        def flag(self):
            return self.getTypedRuleContext(appgenParser.FlagContext,0)


        def execute_query(self):
            return self.getTypedRuleContext(appgenParser.Execute_queryContext,0)


        def upload(self):
            return self.getTypedRuleContext(appgenParser.UploadContext,0)


        def download(self):
            return self.getTypedRuleContext(appgenParser.DownloadContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_actionExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionExpr" ):
                listener.enterActionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionExpr" ):
                listener.exitActionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActionExpr" ):
                return visitor.visitActionExpr(self)
            else:
                return visitor.visitChildren(self)




    def actionExpr(self):

        localctx = appgenParser.ActionExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_actionExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 956
            self.match(appgenParser.T__77)
            self.state = 970
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [80]:
                self.state = 957
                self.python_code()
                pass
            elif token in [79]:
                self.state = 958
                self.match(appgenParser.T__78)
                self.state = 959
                self.match(appgenParser.L_PAR)
                self.state = 960
                self.string()
                self.state = 961
                self.match(appgenParser.R_PAR)
                pass
            elif token in [81]:
                self.state = 963
                self.sms()
                pass
            elif token in [82]:
                self.state = 964
                self.notify()
                pass
            elif token in [83]:
                self.state = 965
                self.search()
                pass
            elif token in [84]:
                self.state = 966
                self.flag()
                pass
            elif token in [87]:
                self.state = 967
                self.execute_query()
                pass
            elif token in [85]:
                self.state = 968
                self.upload()
                pass
            elif token in [86]:
                self.state = 969
                self.download()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Python_codeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_python_code

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPython_code" ):
                listener.enterPython_code(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPython_code" ):
                listener.exitPython_code(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPython_code" ):
                return visitor.visitPython_code(self)
            else:
                return visitor.visitChildren(self)




    def python_code(self):

        localctx = appgenParser.Python_codeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_python_code)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 972
            self.match(appgenParser.T__79)
            self.state = 973
            self.match(appgenParser.L_PAR)
            self.state = 974
            self.string()
            self.state = 975
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SmsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def destination(self):
            return self.getTypedRuleContext(appgenParser.DestinationContext,0)


        def COMMA(self):
            return self.getToken(appgenParser.COMMA, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_sms

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSms" ):
                listener.enterSms(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSms" ):
                listener.exitSms(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSms" ):
                return visitor.visitSms(self)
            else:
                return visitor.visitChildren(self)




    def sms(self):

        localctx = appgenParser.SmsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_sms)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 977
            self.match(appgenParser.T__80)
            self.state = 978
            self.match(appgenParser.L_PAR)
            self.state = 979
            self.destination()
            self.state = 980
            self.match(appgenParser.COMMA)
            self.state = 981
            self.string()
            self.state = 982
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NotifyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_notify

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotify" ):
                listener.enterNotify(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotify" ):
                listener.exitNotify(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotify" ):
                return visitor.visitNotify(self)
            else:
                return visitor.visitChildren(self)




    def notify(self):

        localctx = appgenParser.NotifyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_notify)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 984
            self.match(appgenParser.T__81)
            self.state = 985
            self.match(appgenParser.L_PAR)
            self.state = 986
            self.string()
            self.state = 987
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SearchContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_search

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSearch" ):
                listener.enterSearch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSearch" ):
                listener.exitSearch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSearch" ):
                return visitor.visitSearch(self)
            else:
                return visitor.visitChildren(self)




    def search(self):

        localctx = appgenParser.SearchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_search)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 989
            self.match(appgenParser.T__82)
            self.state = 990
            self.match(appgenParser.L_PAR)
            self.state = 991
            self.string()
            self.state = 992
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FlagContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_flag

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlag" ):
                listener.enterFlag(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlag" ):
                listener.exitFlag(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFlag" ):
                return visitor.visitFlag(self)
            else:
                return visitor.visitChildren(self)




    def flag(self):

        localctx = appgenParser.FlagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_flag)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 994
            self.match(appgenParser.T__83)
            self.state = 995
            self.match(appgenParser.L_PAR)
            self.state = 996
            self.string()
            self.state = 997
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UploadContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def server_loc(self):
            return self.getTypedRuleContext(appgenParser.Server_locContext,0)


        def COMMA(self):
            return self.getToken(appgenParser.COMMA, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_upload

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpload" ):
                listener.enterUpload(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpload" ):
                listener.exitUpload(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpload" ):
                return visitor.visitUpload(self)
            else:
                return visitor.visitChildren(self)




    def upload(self):

        localctx = appgenParser.UploadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_upload)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 999
            self.match(appgenParser.T__84)
            self.state = 1000
            self.match(appgenParser.L_PAR)
            self.state = 1001
            self.server_loc()
            self.state = 1002
            self.match(appgenParser.COMMA)
            self.state = 1003
            self.string()
            self.state = 1004
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DownloadContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def server_loc(self):
            return self.getTypedRuleContext(appgenParser.Server_locContext,0)


        def COMMA(self):
            return self.getToken(appgenParser.COMMA, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_download

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDownload" ):
                listener.enterDownload(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDownload" ):
                listener.exitDownload(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDownload" ):
                return visitor.visitDownload(self)
            else:
                return visitor.visitChildren(self)




    def download(self):

        localctx = appgenParser.DownloadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_download)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1006
            self.match(appgenParser.T__85)
            self.state = 1007
            self.match(appgenParser.L_PAR)
            self.state = 1008
            self.server_loc()
            self.state = 1009
            self.match(appgenParser.COMMA)
            self.state = 1010
            self.string()
            self.state = 1011
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Execute_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_execute_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecute_query" ):
                listener.enterExecute_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecute_query" ):
                listener.exitExecute_query(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecute_query" ):
                return visitor.visitExecute_query(self)
            else:
                return visitor.visitChildren(self)




    def execute_query(self):

        localctx = appgenParser.Execute_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_execute_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1013
            self.match(appgenParser.T__86)
            self.state = 1014
            self.match(appgenParser.L_PAR)
            self.state = 1015
            self.string()
            self.state = 1016
            self.match(appgenParser.R_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DestinationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_destination

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDestination" ):
                listener.enterDestination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDestination" ):
                listener.exitDestination(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDestination" ):
                return visitor.visitDestination(self)
            else:
                return visitor.visitChildren(self)




    def destination(self):

        localctx = appgenParser.DestinationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_destination)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1018
            self.string()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Server_locContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string(self):
            return self.getTypedRuleContext(appgenParser.StringContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_server_loc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServer_loc" ):
                listener.enterServer_loc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServer_loc" ):
                listener.exitServer_loc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitServer_loc" ):
                return visitor.visitServer_loc(self)
            else:
                return visitor.visitChildren(self)




    def server_loc(self):

        localctx = appgenParser.Server_locContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_server_loc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1020
            self.string()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return appgenParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class InverseTrigonometricSinContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseTrigonometricSin" ):
                listener.enterInverseTrigonometricSin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseTrigonometricSin" ):
                listener.exitInverseTrigonometricSin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInverseTrigonometricSin" ):
                return visitor.visitInverseTrigonometricSin(self)
            else:
                return visitor.visitChildren(self)


    class StatisticalMinimumContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MIN(self):
            return self.getToken(appgenParser.MIN, 0)
        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)
        def expr_list(self):
            return self.getTypedRuleContext(appgenParser.Expr_listContext,0)

        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatisticalMinimum" ):
                listener.enterStatisticalMinimum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatisticalMinimum" ):
                listener.exitStatisticalMinimum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatisticalMinimum" ):
                return visitor.visitStatisticalMinimum(self)
            else:
                return visitor.visitChildren(self)


    class BinaryAdditionSubtractionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.ExprContext)
            else:
                return self.getTypedRuleContext(appgenParser.ExprContext,i)

        def ADD(self):
            return self.getToken(appgenParser.ADD, 0)
        def SUB(self):
            return self.getToken(appgenParser.SUB, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryAdditionSubtraction" ):
                listener.enterBinaryAdditionSubtraction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryAdditionSubtraction" ):
                listener.exitBinaryAdditionSubtraction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryAdditionSubtraction" ):
                return visitor.visitBinaryAdditionSubtraction(self)
            else:
                return visitor.visitChildren(self)


    class BooleanCombinationContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.ExprContext)
            else:
                return self.getTypedRuleContext(appgenParser.ExprContext,i)

        def booleanOp(self):
            return self.getTypedRuleContext(appgenParser.BooleanOpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanCombination" ):
                listener.enterBooleanCombination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanCombination" ):
                listener.exitBooleanCombination(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanCombination" ):
                return visitor.visitBooleanCombination(self)
            else:
                return visitor.visitChildren(self)


    class NestedExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)
        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)

        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedExpr" ):
                listener.enterNestedExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedExpr" ):
                listener.exitNestedExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNestedExpr" ):
                return visitor.visitNestedExpr(self)
            else:
                return visitor.visitChildren(self)


    class TrigonometricCosContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrigonometricCos" ):
                listener.enterTrigonometricCos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrigonometricCos" ):
                listener.exitTrigonometricCos(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrigonometricCos" ):
                return visitor.visitTrigonometricCos(self)
            else:
                return visitor.visitChildren(self)


    class InverseTrigonometricTanContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseTrigonometricTan" ):
                listener.enterInverseTrigonometricTan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseTrigonometricTan" ):
                listener.exitInverseTrigonometricTan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInverseTrigonometricTan" ):
                return visitor.visitInverseTrigonometricTan(self)
            else:
                return visitor.visitChildren(self)


    class InverseHyperbolicTangentContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseHyperbolicTangent" ):
                listener.enterInverseHyperbolicTangent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseHyperbolicTangent" ):
                listener.exitInverseHyperbolicTangent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInverseHyperbolicTangent" ):
                return visitor.visitInverseHyperbolicTangent(self)
            else:
                return visitor.visitChildren(self)


    class BinaryComparisonContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.ExprContext)
            else:
                return self.getTypedRuleContext(appgenParser.ExprContext,i)

        def comparisonOp(self):
            return self.getTypedRuleContext(appgenParser.ComparisonOpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparison" ):
                listener.enterBinaryComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparison" ):
                listener.exitBinaryComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparison" ):
                return visitor.visitBinaryComparison(self)
            else:
                return visitor.visitChildren(self)


    class TrigonometricTanContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrigonometricTan" ):
                listener.enterTrigonometricTan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrigonometricTan" ):
                listener.exitTrigonometricTan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrigonometricTan" ):
                return visitor.visitTrigonometricTan(self)
            else:
                return visitor.visitChildren(self)


    class LiteralExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(appgenParser.LiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteralExpr" ):
                listener.enterLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteralExpr" ):
                listener.exitLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralExpr" ):
                return visitor.visitLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class FunctionCallExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionCall(self):
            return self.getTypedRuleContext(appgenParser.FunctionCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCallExpr" ):
                listener.enterFunctionCallExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCallExpr" ):
                listener.exitFunctionCallExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCallExpr" ):
                return visitor.visitFunctionCallExpr(self)
            else:
                return visitor.visitChildren(self)


    class StatisticalAverageContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)
        def expr_list(self):
            return self.getTypedRuleContext(appgenParser.Expr_listContext,0)

        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatisticalAverage" ):
                listener.enterStatisticalAverage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatisticalAverage" ):
                listener.exitStatisticalAverage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatisticalAverage" ):
                return visitor.visitStatisticalAverage(self)
            else:
                return visitor.visitChildren(self)


    class BinaryMultiplicationDivContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.ExprContext)
            else:
                return self.getTypedRuleContext(appgenParser.ExprContext,i)

        def MUL(self):
            return self.getToken(appgenParser.MUL, 0)
        def DIV(self):
            return self.getToken(appgenParser.DIV, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryMultiplicationDiv" ):
                listener.enterBinaryMultiplicationDiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryMultiplicationDiv" ):
                listener.exitBinaryMultiplicationDiv(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryMultiplicationDiv" ):
                return visitor.visitBinaryMultiplicationDiv(self)
            else:
                return visitor.visitChildren(self)


    class HyperbolicCosineContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHyperbolicCosine" ):
                listener.enterHyperbolicCosine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHyperbolicCosine" ):
                listener.exitHyperbolicCosine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHyperbolicCosine" ):
                return visitor.visitHyperbolicCosine(self)
            else:
                return visitor.visitChildren(self)


    class StatisticalMaximumContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MAX(self):
            return self.getToken(appgenParser.MAX, 0)
        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)
        def expr_list(self):
            return self.getTypedRuleContext(appgenParser.Expr_listContext,0)

        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatisticalMaximum" ):
                listener.enterStatisticalMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatisticalMaximum" ):
                listener.exitStatisticalMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatisticalMaximum" ):
                return visitor.visitStatisticalMaximum(self)
            else:
                return visitor.visitChildren(self)


    class TrigonometricSinContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrigonometricSin" ):
                listener.enterTrigonometricSin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrigonometricSin" ):
                listener.exitTrigonometricSin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrigonometricSin" ):
                return visitor.visitTrigonometricSin(self)
            else:
                return visitor.visitChildren(self)


    class InverseHyperbolicCosineContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseHyperbolicCosine" ):
                listener.enterInverseHyperbolicCosine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseHyperbolicCosine" ):
                listener.exitInverseHyperbolicCosine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInverseHyperbolicCosine" ):
                return visitor.visitInverseHyperbolicCosine(self)
            else:
                return visitor.visitChildren(self)


    class InverseHyperbolicSineContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseHyperbolicSine" ):
                listener.enterInverseHyperbolicSine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseHyperbolicSine" ):
                listener.exitInverseHyperbolicSine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInverseHyperbolicSine" ):
                return visitor.visitInverseHyperbolicSine(self)
            else:
                return visitor.visitChildren(self)


    class StatisticalSumContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def L_PAR(self):
            return self.getToken(appgenParser.L_PAR, 0)
        def expr_list(self):
            return self.getTypedRuleContext(appgenParser.Expr_listContext,0)

        def R_PAR(self):
            return self.getToken(appgenParser.R_PAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatisticalSum" ):
                listener.enterStatisticalSum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatisticalSum" ):
                listener.exitStatisticalSum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatisticalSum" ):
                return visitor.visitStatisticalSum(self)
            else:
                return visitor.visitChildren(self)


    class HyperbolicTangentContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHyperbolicTangent" ):
                listener.enterHyperbolicTangent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHyperbolicTangent" ):
                listener.exitHyperbolicTangent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHyperbolicTangent" ):
                return visitor.visitHyperbolicTangent(self)
            else:
                return visitor.visitChildren(self)


    class InverseTrigonometricCosContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInverseTrigonometricCos" ):
                listener.enterInverseTrigonometricCos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInverseTrigonometricCos" ):
                listener.exitInverseTrigonometricCos(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInverseTrigonometricCos" ):
                return visitor.visitInverseTrigonometricCos(self)
            else:
                return visitor.visitChildren(self)


    class HyperbolicSineContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHyperbolicSine" ):
                listener.enterHyperbolicSine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHyperbolicSine" ):
                listener.exitHyperbolicSine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHyperbolicSine" ):
                return visitor.visitHyperbolicSine(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SUB(self):
            return self.getToken(appgenParser.SUB, 0)
        def expr(self):
            return self.getTypedRuleContext(appgenParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinus" ):
                listener.enterUnaryMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinus" ):
                listener.exitUnaryMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinus" ):
                return visitor.visitUnaryMinus(self)
            else:
                return visitor.visitChildren(self)


    class IdentExpressionContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a appgenParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ident(self):
            return self.getTypedRuleContext(appgenParser.IdentContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentExpression" ):
                listener.enterIdentExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentExpression" ):
                listener.exitIdentExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentExpression" ):
                return visitor.visitIdentExpression(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = appgenParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 212
        self.enterRecursionRule(localctx, 212, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1076
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [130]:
                localctx = appgenParser.IdentExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1023
                self.ident()
                pass
            elif token in [131, 132, 134, 135, 136]:
                localctx = appgenParser.LiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1024
                self.literal()
                pass
            elif token in [102]:
                localctx = appgenParser.FunctionCallExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1025
                self.functionCall()
                pass
            elif token in [107]:
                localctx = appgenParser.NestedExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1026
                self.match(appgenParser.L_PAR)
                self.state = 1027
                self.expr(0)
                self.state = 1028
                self.match(appgenParser.R_PAR)
                pass
            elif token in [115]:
                localctx = appgenParser.UnaryMinusContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1030
                self.match(appgenParser.SUB)
                self.state = 1031
                self.expr(17)
                pass
            elif token in [88]:
                localctx = appgenParser.TrigonometricSinContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1032
                self.match(appgenParser.T__87)
                self.state = 1033
                self.expr(16)
                pass
            elif token in [89]:
                localctx = appgenParser.TrigonometricCosContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1034
                self.match(appgenParser.T__88)
                self.state = 1035
                self.expr(15)
                pass
            elif token in [90]:
                localctx = appgenParser.TrigonometricTanContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1036
                self.match(appgenParser.T__89)
                self.state = 1037
                self.expr(14)
                pass
            elif token in [91]:
                localctx = appgenParser.InverseTrigonometricSinContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1038
                self.match(appgenParser.T__90)
                self.state = 1039
                self.expr(13)
                pass
            elif token in [92]:
                localctx = appgenParser.InverseTrigonometricCosContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1040
                self.match(appgenParser.T__91)
                self.state = 1041
                self.expr(12)
                pass
            elif token in [93]:
                localctx = appgenParser.InverseTrigonometricTanContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1042
                self.match(appgenParser.T__92)
                self.state = 1043
                self.expr(11)
                pass
            elif token in [94]:
                localctx = appgenParser.HyperbolicSineContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1044
                self.match(appgenParser.T__93)
                self.state = 1045
                self.expr(10)
                pass
            elif token in [95]:
                localctx = appgenParser.HyperbolicCosineContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1046
                self.match(appgenParser.T__94)
                self.state = 1047
                self.expr(9)
                pass
            elif token in [96]:
                localctx = appgenParser.HyperbolicTangentContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1048
                self.match(appgenParser.T__95)
                self.state = 1049
                self.expr(8)
                pass
            elif token in [97]:
                localctx = appgenParser.InverseHyperbolicSineContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1050
                self.match(appgenParser.T__96)
                self.state = 1051
                self.expr(7)
                pass
            elif token in [98]:
                localctx = appgenParser.InverseHyperbolicCosineContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1052
                self.match(appgenParser.T__97)
                self.state = 1053
                self.expr(6)
                pass
            elif token in [99]:
                localctx = appgenParser.InverseHyperbolicTangentContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1054
                self.match(appgenParser.T__98)
                self.state = 1055
                self.expr(5)
                pass
            elif token in [100]:
                localctx = appgenParser.StatisticalAverageContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1056
                self.match(appgenParser.T__99)
                self.state = 1057
                self.match(appgenParser.L_PAR)
                self.state = 1058
                self.expr_list()
                self.state = 1059
                self.match(appgenParser.R_PAR)
                pass
            elif token in [176]:
                localctx = appgenParser.StatisticalMinimumContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1061
                self.match(appgenParser.MIN)
                self.state = 1062
                self.match(appgenParser.L_PAR)
                self.state = 1063
                self.expr_list()
                self.state = 1064
                self.match(appgenParser.R_PAR)
                pass
            elif token in [177]:
                localctx = appgenParser.StatisticalMaximumContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1066
                self.match(appgenParser.MAX)
                self.state = 1067
                self.match(appgenParser.L_PAR)
                self.state = 1068
                self.expr_list()
                self.state = 1069
                self.match(appgenParser.R_PAR)
                pass
            elif token in [101]:
                localctx = appgenParser.StatisticalSumContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1071
                self.match(appgenParser.T__100)
                self.state = 1072
                self.match(appgenParser.L_PAR)
                self.state = 1073
                self.expr_list()
                self.state = 1074
                self.match(appgenParser.R_PAR)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 1094
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,77,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1092
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                    if la_ == 1:
                        localctx = appgenParser.BinaryMultiplicationDivContext(self, appgenParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1078
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 1079
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==116 or _la==117):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1080
                        self.expr(22)
                        pass

                    elif la_ == 2:
                        localctx = appgenParser.BinaryAdditionSubtractionContext(self, appgenParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1081
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 1082
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==114 or _la==115):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1083
                        self.expr(21)
                        pass

                    elif la_ == 3:
                        localctx = appgenParser.BooleanCombinationContext(self, appgenParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1084
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 1085
                        self.booleanOp()
                        self.state = 1086
                        self.expr(20)
                        pass

                    elif la_ == 4:
                        localctx = appgenParser.BinaryComparisonContext(self, appgenParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1088
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 1089
                        self.comparisonOp()
                        self.state = 1090
                        self.expr(19)
                        pass

             
                self.state = 1096
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,77,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Expr_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(appgenParser.ExprContext)
            else:
                return self.getTypedRuleContext(appgenParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(appgenParser.COMMA)
            else:
                return self.getToken(appgenParser.COMMA, i)

        def getRuleIndex(self):
            return appgenParser.RULE_expr_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_list" ):
                listener.enterExpr_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_list" ):
                listener.exitExpr_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_list" ):
                return visitor.visitExpr_list(self)
            else:
                return visitor.visitChildren(self)




    def expr_list(self):

        localctx = appgenParser.Expr_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_expr_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1097
            self.expr(0)
            self.state = 1102
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,78,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1098
                    self.match(appgenParser.COMMA)
                    self.state = 1099
                    self.expr(0) 
                self.state = 1104
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,78,self._ctx)

            self.state = 1106
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 1105
                self.match(appgenParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(appgenParser.INT, 0)

        def FLOAT(self):
            return self.getToken(appgenParser.FLOAT, 0)

        def STRING(self):
            return self.getToken(appgenParser.STRING, 0)

        def TRUE(self):
            return self.getToken(appgenParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(appgenParser.FALSE, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = appgenParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1108
            _la = self._input.LA(1)
            if not(((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & 59) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(appgenParser.AND, 0)

        def OR(self):
            return self.getToken(appgenParser.OR, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_booleanOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanOp" ):
                listener.enterBooleanOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanOp" ):
                listener.exitBooleanOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanOp" ):
                return visitor.visitBooleanOp(self)
            else:
                return visitor.visitChildren(self)




    def booleanOp(self):

        localctx = appgenParser.BooleanOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_booleanOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1110
            _la = self._input.LA(1)
            if not(_la==124 or _la==125):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(appgenParser.EQ, 0)

        def NEQ(self):
            return self.getToken(appgenParser.NEQ, 0)

        def LT(self):
            return self.getToken(appgenParser.LT, 0)

        def LTE(self):
            return self.getToken(appgenParser.LTE, 0)

        def GT(self):
            return self.getToken(appgenParser.GT, 0)

        def GTE(self):
            return self.getToken(appgenParser.GTE, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_comparisonOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOp" ):
                listener.enterComparisonOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOp" ):
                listener.exitComparisonOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOp" ):
                return visitor.visitComparisonOp(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOp(self):

        localctx = appgenParser.ComparisonOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_comparisonOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1112
            _la = self._input.LA(1)
            if not(((((_la - 106)) & ~0x3f) == 0 and ((1 << (_la - 106)) & 241665) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(appgenParser.ADD, 0)

        def SUB(self):
            return self.getToken(appgenParser.SUB, 0)

        def MUL(self):
            return self.getToken(appgenParser.MUL, 0)

        def DIV(self):
            return self.getToken(appgenParser.DIV, 0)

        def getRuleIndex(self):
            return appgenParser.RULE_arithmeticOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticOp" ):
                listener.enterArithmeticOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticOp" ):
                listener.exitArithmeticOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticOp" ):
                return visitor.visitArithmeticOp(self)
            else:
                return visitor.visitChildren(self)




    def arithmeticOp(self):

        localctx = appgenParser.ArithmeticOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_arithmeticOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1114
            _la = self._input.LA(1)
            if not(((((_la - 114)) & ~0x3f) == 0 and ((1 << (_la - 114)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_name(self):
            return self.getTypedRuleContext(appgenParser.Function_nameContext,0)


        def param_list(self):
            return self.getTypedRuleContext(appgenParser.Param_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = appgenParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_functionCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1116
            self.match(appgenParser.T__101)
            self.state = 1117
            self.function_name()
            self.state = 1119
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
            if la_ == 1:
                self.state = 1118
                self.param_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_attr(self):
            return self.getTypedRuleContext(appgenParser.Name_attrContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_name" ):
                listener.enterFunction_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_name" ):
                listener.exitFunction_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_name" ):
                return visitor.visitFunction_name(self)
            else:
                return visitor.visitChildren(self)




    def function_name(self):

        localctx = appgenParser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1121
            self.name_attr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Param_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string_list(self):
            return self.getTypedRuleContext(appgenParser.String_listContext,0)


        def getRuleIndex(self):
            return appgenParser.RULE_param_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParam_list" ):
                listener.enterParam_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParam_list" ):
                listener.exitParam_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParam_list" ):
                return visitor.visitParam_list(self)
            else:
                return visitor.visitChildren(self)




    def param_list(self):

        localctx = appgenParser.Param_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_param_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1123
            self.string_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[106] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 18)
         




