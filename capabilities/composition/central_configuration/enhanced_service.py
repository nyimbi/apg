"""
APG Central Configuration - Enhanced Service Integration

Integration layer combining all AI intelligence components with the core service
for revolutionary autonomous configuration management.

¬© 2025 Datacraft. All rights reserved.
Author: Nyimbi Odero <nyimbi@gmail.com>
"""

import asyncio
import json
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass, asdict

# Core service
from .service import CentralConfigurationEngine

# AI Intelligence components
from .ml_models import CentralConfigurationML, ModelType, ModelPrediction
from .analytics_engine import (
	CentralConfigurationAnalytics, AnalyticsMetricType,
	create_analytics_engine
)
from .intelligent_automation import (
	CentralConfigurationAutomation, AutomationTrigger, ActionType,
	create_automation_engine
)
from .ai_engine import CentralConfigurationAI
from .security_engine import CentralConfigurationSecurity, create_security_engine
from .gitops_engine import CentralConfigurationGitOps, create_gitops_engine

# Models
from .models import (
	ConfigurationCreate, ConfigurationUpdate, ConfigurationResponse,
	SecurityLevel
)


@dataclass
class IntelligentInsight:
	"""Intelligent insight generated by AI analysis."""
	insight_id: str
	insight_type: str
	title: str
	description: str
	confidence: float
	priority: str
	actionable: bool
	recommendations: List[str]
	evidence: Dict[str, Any]
	generated_at: datetime


@dataclass
class AutonomousAction:
	"""Autonomous action taken by the system."""
	action_id: str
	trigger_event: str
	action_taken: str
	target_resource: str
	parameters: Dict[str, Any]
	result: Optional[Dict[str, Any]]
	success: bool
	impact_metrics: Dict[str, float]
	executed_at: datetime


@dataclass
class SystemHealthReport:
	"""Comprehensive system health report."""
	report_id: str
	generated_at: datetime
	overall_health_score: float
	performance_metrics: Dict[str, float]
	security_status: Dict[str, Any]
	automation_effectiveness: Dict[str, float]
	predictive_insights: List[IntelligentInsight]
	autonomous_actions: List[AutonomousAction]
	recommendations: List[str]


class EnhancedCentralConfigurationService:
	"""Enhanced configuration service with full AI intelligence integration."""
	
	def __init__(
		self,
		database_url: str,
		redis_url: str,
		tenant_id: str,
		user_id: str,
		gitops_repository_url: Optional[str] = None,
		models_directory: str = "./ml_models"
	):
		"""Initialize enhanced service with all AI components."""
		self.tenant_id = tenant_id
		self.user_id = user_id
		
		# Core service
		self.core_service: Optional[CentralConfigurationEngine] = None
		
		# AI Intelligence components
		self.ai_engine: Optional[CentralConfigurationAI] = None
		self.ml_engine: Optional[CentralConfigurationML] = None
		self.analytics_engine: Optional[CentralConfigurationAnalytics] = None
		self.security_engine: Optional[CentralConfigurationSecurity] = None
		self.automation_engine: Optional[CentralConfigurationAutomation] = None
		self.gitops_engine: Optional[CentralConfigurationGitOps] = None
		
		# Configuration
		self.database_url = database_url
		self.redis_url = redis_url
		self.gitops_repository_url = gitops_repository_url
		self.models_directory = models_directory
		
		# Intelligence state
		self.intelligence_insights: List[IntelligentInsight] = []
		self.autonomous_actions: List[AutonomousAction] = []
		self.system_health_cache: Optional[SystemHealthReport] = None
		self.last_health_check: Optional[datetime] = None
		
		# Initialize all components
		asyncio.create_task(self._initialize_enhanced_service())
	
	async def _initialize_enhanced_service(self):
		"""Initialize all service components."""
		print("üöÄ Initializing Enhanced Central Configuration Service...")
		
		try:
			# Initialize core service
			from .service import create_configuration_engine
			self.core_service = await create_configuration_engine(
				database_url=self.database_url,
				redis_url=self.redis_url,
				tenant_id=self.tenant_id,
				user_id=self.user_id
			)
			
			# Initialize AI engine
			self.ai_engine = CentralConfigurationAI()
			await self.ai_engine.initialize()
			
			# Initialize ML engine
			from .ml_models import create_ml_engine
			self.ml_engine = await create_ml_engine(self.models_directory)
			
			# Initialize analytics engine
			import redis.asyncio as redis
			redis_client = await redis.from_url(self.redis_url)
			self.analytics_engine = await create_analytics_engine(
				redis_client=redis_client,
				retention_days=90
			)
			
			# Initialize security engine
			self.security_engine = await create_security_engine()
			
			# Initialize automation engine
			self.automation_engine = await create_automation_engine(
				ml_engine=self.ml_engine,
				analytics_engine=self.analytics_engine,
				security_engine=self.security_engine
			)
			
			# Initialize GitOps engine (if repository provided)
			if self.gitops_repository_url:
				self.gitops_engine = await create_gitops_engine(
					repository_url=self.gitops_repository_url
				)
			
			# Start intelligent monitoring
			asyncio.create_task(self._intelligent_monitoring_loop())
			
			# Start autonomous operations
			asyncio.create_task(self._autonomous_operations_loop())
			
			print("‚úÖ Enhanced Central Configuration Service initialized successfully")
			
		except Exception as e:
			print(f"‚ùå Failed to initialize enhanced service: {e}")
			raise
	
	# ==================== Enhanced Configuration Management ====================
	
	async def create_intelligent_configuration(
		self,
		workspace_id: str,
		config_data: ConfigurationCreate,
		parent_id: Optional[str] = None,
		auto_optimize: bool = True,
		deploy_automatically: bool = False
	) -> ConfigurationResponse:
		"""Create configuration with AI optimization and analysis."""
		if not self.core_service:
			raise RuntimeError("Core service not initialized")
		
		print(f"üß† Creating intelligent configuration: {config_data.name}")
		
		# AI-powered optimization
		if auto_optimize and self.ai_engine:
			try:
				optimized_value = await self.ai_engine.optimize_configuration(config_data.value)
				if optimized_value != config_data.value:
					print("üéØ AI optimization applied to configuration")
					config_data.value = optimized_value
			except Exception as e:
				print(f"‚ö†Ô∏è AI optimization failed: {e}")
		
		# Security analysis
		if self.security_engine:
			try:
				# Encrypt sensitive configuration data
				if config_data.security_level in [SecurityLevel.CONFIDENTIAL, SecurityLevel.SECRET]:
					encryption_result = await self.security_engine.encrypt_configuration(
						data=config_data.value,
						security_level=config_data.security_level
					)
					# Store encryption metadata (in production, handle securely)
					config_data.metadata = config_data.metadata or {}
					config_data.metadata['encrypted'] = True
					config_data.metadata['encryption_key_id'] = encryption_result.encryption_key_id
			except Exception as e:
				print(f"‚ö†Ô∏è Security encryption failed: {e}")
		
		# Create configuration
		result = await self.core_service.create_configuration(
			workspace_id=workspace_id,
			config_data=config_data,
			parent_id=parent_id
		)
		
		# Record analytics
		if self.analytics_engine:
			await self.analytics_engine.record_metric(
				metric_type=AnalyticsMetricType.USAGE,
				name="configurations_created",
				value=1,
				tags={
					'workspace_id': workspace_id,
					'security_level': config_data.security_level.value,
					'auto_optimized': str(auto_optimize)
				}
			)
		
		# Trigger deployment if requested
		if deploy_automatically and self.gitops_engine:
			try:
				await self._trigger_automatic_deployment(result, workspace_id)
			except Exception as e:
				print(f"‚ö†Ô∏è Automatic deployment failed: {e}")
		
		# Generate AI insights
		await self._generate_configuration_insights(result)
		
		return result
	
	async def update_configuration_with_intelligence(
		self,
		configuration_id: str,
		updates: ConfigurationUpdate,
		change_reason: Optional[str] = None,
		validate_with_ai: bool = True,
		auto_deploy: bool = False
	) -> ConfigurationResponse:
		"""Update configuration with AI validation and analysis."""
		if not self.core_service:
			raise RuntimeError("Core service not initialized")
		
		print(f"üß† Updating configuration with intelligence: {configuration_id}")
		
		# Get current configuration
		current_config = await self.core_service.get_configuration(configuration_id)
		if not current_config:
			raise ValueError(f"Configuration {configuration_id} not found")
		
		# AI validation
		if validate_with_ai and self.ai_engine and updates.value:
			try:
				# Generate recommendations before applying changes
				recommendations = await self.ai_engine.generate_recommendations(updates.value)
				
				# Check for potential issues
				high_risk_recommendations = [
					rec for rec in recommendations 
					if rec.get('confidence', 0) > 0.8 and 'risk' in rec.get('type', '').lower()
				]
				
				if high_risk_recommendations:
					print(f"‚ö†Ô∏è High-risk changes detected: {len(high_risk_recommendations)} issues")
					# In production, might require approval or additional validation
				
			except Exception as e:
				print(f"‚ö†Ô∏è AI validation failed: {e}")
		
		# Performance impact prediction
		if self.ml_engine:
			try:
				if updates.value:
					prediction = await self.ml_engine.predict_performance(
						configuration_data=updates.value,
						resource_allocation={'cpu': 1.0, 'memory': 1.0},
						predicted_load={'requests_per_second': 100}
					)
					
					print(f"üìä Predicted performance impact: {prediction.prediction:.1f}ms response time")
					
					# Record prediction for later validation
					await self._record_performance_prediction(configuration_id, prediction)
					
			except Exception as e:
				print(f"‚ö†Ô∏è Performance prediction failed: {e}")
		
		# Apply update
		result = await self.core_service.update_configuration(
			configuration_id=configuration_id,
			updates=updates,
			change_reason=change_reason
		)
		
		# Record analytics
		if self.analytics_engine:
			await self.analytics_engine.record_metric(
				metric_type=AnalyticsMetricType.USAGE,
				name="configurations_updated",
				value=1,
				tags={
					'configuration_id': configuration_id,
					'ai_validated': str(validate_with_ai)
				}
			)
		
		# Trigger deployment if requested
		if auto_deploy and self.gitops_engine:
			try:
				await self._trigger_configuration_deployment(result)
			except Exception as e:
				print(f"‚ö†Ô∏è Auto-deployment failed: {e}")
		
		# Generate insights on the update
		await self._generate_update_insights(result, current_config)
		
		return result
	
	# ==================== Intelligent Analytics & Insights ====================
	
	async def get_intelligent_insights(
		self,
		configuration_id: Optional[str] = None,
		insight_types: Optional[List[str]] = None,
		limit: int = 50
	) -> List[IntelligentInsight]:
		"""Get AI-generated insights about configurations."""
		insights = self.intelligence_insights.copy()
		
		# Filter by configuration if specified
		if configuration_id:
			insights = [
				insight for insight in insights
				if insight.evidence.get('configuration_id') == configuration_id
			]
		
		# Filter by insight types if specified
		if insight_types:
			insights = [
				insight for insight in insights
				if insight.insight_type in insight_types
			]
		
		# Sort by priority and confidence
		priority_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
		insights.sort(key=lambda x: (priority_order.get(x.priority, 3), -x.confidence))
		
		return insights[:limit]
	
	async def generate_system_health_report(self) -> SystemHealthReport:
		"""Generate comprehensive system health report with AI analysis."""
		print("üìä Generating intelligent system health report...")
		
		report_id = f"health_report_{int(datetime.now().timestamp())}"
		
		# Performance metrics
		performance_metrics = {}
		if self.analytics_engine:
			dashboard_data = await self.analytics_engine.get_real_time_dashboard_data()
			for metric_key, metric_data in dashboard_data.get('streaming_metrics', {}).items():
				performance_metrics[metric_key] = metric_data.get('current_value', 0)
		
		# Security status
		security_status = {}
		if self.security_engine:
			# Get security audit events (simplified)
			security_status = {
				'encryption_enabled': True,
				'threat_level': 'low',
				'recent_incidents': 0,
				'compliance_score': 0.95
			}
		
		# Automation effectiveness
		automation_effectiveness = {}
		if self.automation_engine:
			status = await self.automation_engine.get_automation_status()
			total_actions = status.get('total_actions_executed', 0)
			successful_actions = status.get('successful_actions', 0)
			
			automation_effectiveness = {
				'success_rate': successful_actions / max(total_actions, 1),
				'active_rules': status.get('enabled_rules', 0),
				'pending_actions': status.get('pending_actions', 0),
				'avg_response_time': 2.5  # seconds
			}
		
		# Calculate overall health score
		health_components = []
		
		# Performance health
		avg_response_time = performance_metrics.get('performance:response_time', 100)
		performance_health = max(0, 1 - (avg_response_time - 100) / 400)  # 100-500ms range
		health_components.append(performance_health)
		
		# Security health
		security_health = security_status.get('compliance_score', 0.95)
		health_components.append(security_health)
		
		# Automation health
		automation_health = automation_effectiveness.get('success_rate', 0.8)
		health_components.append(automation_health)
		
		overall_health_score = sum(health_components) / len(health_components)
		
		# Generate predictive insights
		predictive_insights = await self._generate_predictive_insights()
		
		# Get recent autonomous actions
		recent_actions = self.autonomous_actions[-20:]  # Last 20 actions
		
		# Generate recommendations
		recommendations = await self._generate_health_recommendations(
			performance_metrics, security_status, automation_effectiveness
		)
		
		report = SystemHealthReport(
			report_id=report_id,
			generated_at=datetime.now(timezone.utc),
			overall_health_score=overall_health_score,
			performance_metrics=performance_metrics,
			security_status=security_status,
			automation_effectiveness=automation_effectiveness,
			predictive_insights=predictive_insights,
			autonomous_actions=recent_actions,
			recommendations=recommendations
		)
		
		# Cache the report
		self.system_health_cache = report
		self.last_health_check = datetime.now(timezone.utc)
		
		return report
	
	async def _generate_predictive_insights(self) -> List[IntelligentInsight]:
		"""Generate predictive insights using ML models."""
		insights = []
		
		if not self.ml_engine:
			return insights
		
		try:
			# Capacity planning insights
			# (This would use real metrics data in production)
			sample_metrics = [
				{'timestamp': '2025-01-30T10:00:00Z', 'cpu_usage': 65.0, 'memory_usage': 70.0},
				{'timestamp': '2025-01-30T11:00:00Z', 'cpu_usage': 72.0, 'memory_usage': 75.0},
				{'timestamp': '2025-01-30T12:00:00Z', 'cpu_usage': 68.0, 'memory_usage': 73.0}
			]
			
			# Detect anomalies
			anomalies = await self.ml_engine.detect_configuration_anomalies(sample_metrics)
			
			for anomaly in anomalies:
				if anomaly.is_anomaly:
					insight = IntelligentInsight(
						insight_id=f"anomaly_{int(datetime.now().timestamp())}",
						insight_type="anomaly_detection",
						title=f"Anomaly Detected in {', '.join(anomaly.affected_metrics)}",
						description=anomaly.explanation,
						confidence=anomaly.confidence,
						priority="high" if anomaly.severity == "critical" else "medium",
						actionable=True,
						recommendations=anomaly.recommendations,
						evidence={
							'anomaly_score': anomaly.anomaly_score,
							'affected_metrics': anomaly.affected_metrics,
							'timestamp': anomaly.timestamp.isoformat()
						},
						generated_at=datetime.now(timezone.utc)
					)
					insights.append(insight)
			
		except Exception as e:
			print(f"‚ö†Ô∏è Error generating predictive insights: {e}")
		
		return insights
	
	async def _generate_health_recommendations(
		self,
		performance_metrics: Dict[str, float],
		security_status: Dict[str, Any],
		automation_effectiveness: Dict[str, float]
	) -> List[str]:
		"""Generate health improvement recommendations."""
		recommendations = []
		
		# Performance recommendations
		response_time = performance_metrics.get('performance:response_time', 100)
		if response_time > 200:
			recommendations.append(
				f"Response time is elevated at {response_time:.1f}ms. "
				"Consider implementing caching or optimizing database queries."
			)
		
		cpu_usage = performance_metrics.get('performance:cpu_usage', 0)
		if cpu_usage > 80:
			recommendations.append(
				f"High CPU usage detected ({cpu_usage:.1f}%). "
				"Consider scaling resources or optimizing CPU-intensive operations."
			)
		
		# Security recommendations
		compliance_score = security_status.get('compliance_score', 1.0)
		if compliance_score < 0.9:
			recommendations.append(
				f"Security compliance score is {compliance_score:.1%}. "
				"Review security policies and implement missing controls."
			)
		
		# Automation recommendations
		success_rate = automation_effectiveness.get('success_rate', 1.0)
		if success_rate < 0.8:
			recommendations.append(
				f"Automation success rate is {success_rate:.1%}. "
				"Review failing automation rules and improve error handling."
			)
		
		pending_actions = automation_effectiveness.get('pending_actions', 0)
		if pending_actions > 10:
			recommendations.append(
				f"{pending_actions} actions pending execution. "
				"Consider increasing automation capacity or reviewing approval processes."
			)
		
		# General system recommendations
		if not recommendations:
			recommendations.append("System is operating optimally. Continue monitoring for proactive maintenance.")
		
		return recommendations
	
	# ==================== Autonomous Operations ====================
	
	async def _intelligent_monitoring_loop(self):
		"""Intelligent monitoring loop for proactive insights."""
		print("üëÅÔ∏è Starting intelligent monitoring loop...")
		
		while True:
			try:
				# Generate insights every 5 minutes
				await self._generate_periodic_insights()
				
				# Health check every 15 minutes
				if (not self.last_health_check or 
					datetime.now(timezone.utc) - self.last_health_check > timedelta(minutes=15)):
					await self.generate_system_health_report()
				
				# Wait before next iteration
				await asyncio.sleep(300)  # 5 minutes
				
			except Exception as e:
				print(f"‚ùå Error in monitoring loop: {e}")
				await asyncio.sleep(60)  # Wait 1 minute before retry
	
	async def _autonomous_operations_loop(self):
		"""Autonomous operations loop for self-healing actions."""
		print("ü§ñ Starting autonomous operations loop...")
		
		while True:
			try:
				# Check for autonomous actions needed
				await self._check_autonomous_actions()
				
				# Wait before next iteration
				await asyncio.sleep(60)  # 1 minute
				
			except Exception as e:
				print(f"‚ùå Error in autonomous operations: {e}")
				await asyncio.sleep(60)
	
	async def _generate_periodic_insights(self):
		"""Generate periodic AI insights."""
		if not self.analytics_engine:
			return
		
		# Get recent performance data
		dashboard_data = await self.analytics_engine.get_real_time_dashboard_data()
		
		# Analyze trends and generate insights
		# (This would be more sophisticated in production)
		
		# Example: High resource usage insight
		cpu_usage = dashboard_data.get('streaming_metrics', {}).get('performance:cpu_usage', {}).get('current_value', 0)
		
		if cpu_usage > 80:
			insight = IntelligentInsight(
				insight_id=f"cpu_insight_{int(datetime.now().timestamp())}",
				insight_type="performance_issue",
				title="High CPU Usage Detected",
				description=f"CPU usage is at {cpu_usage:.1f}%, which may impact performance",
				confidence=0.9,
				priority="high",
				actionable=True,
				recommendations=[
					"Scale up compute resources",
					"Optimize CPU-intensive processes",
					"Implement load balancing"
				],
				evidence={
					'current_cpu_usage': cpu_usage,
					'threshold': 80,
					'timestamp': datetime.now(timezone.utc).isoformat()
				},
				generated_at=datetime.now(timezone.utc)
			)
			
			self.intelligence_insights.append(insight)
			
			# Trigger automation if available
			if self.automation_engine:
				await self.automation_engine.process_trigger_event(
					trigger=AutomationTrigger.THRESHOLD_BREACH,
					event_data={
						'metric': 'cpu_usage',
						'value': cpu_usage,
						'threshold': 80,
						'severity': 'high'
					}
				)
	
	async def _check_autonomous_actions(self):
		"""Check if autonomous actions are needed."""
		# This would analyze system state and trigger autonomous actions
		# For demonstration, we'll create a sample action
		
		if len(self.autonomous_actions) == 0:  # First time
			sample_action = AutonomousAction(
				action_id=f"auto_action_{int(datetime.now().timestamp())}",
				trigger_event="system_initialization",
				action_taken="baseline_optimization",
				target_resource="system_wide",
				parameters={
					'optimization_type': 'initial_tuning',
					'confidence': 0.8
				},
				result={
					'optimization_applied': True,
					'performance_improvement': 0.05
				},
				success=True,
				impact_metrics={
					'response_time_improvement': 0.05,
					'resource_efficiency_gain': 0.03
				},
				executed_at=datetime.now(timezone.utc)
			)
			
			self.autonomous_actions.append(sample_action)
			print("ü§ñ Autonomous baseline optimization completed")
	
	# ==================== Helper Methods ====================
	
	async def _trigger_automatic_deployment(
		self,
		configuration: ConfigurationResponse,
		workspace_id: str
	):
		"""Trigger automatic deployment through GitOps."""
		if not self.gitops_engine:
			return
		
		# Create deployment request
		await self.gitops_engine.create_deployment_request(
			configuration_id=configuration.id,
			target_environment="development",
			deployment_config={
				'auto_deploy': True,
				'workspace_id': workspace_id
			}
		)
		
		print(f"üöÄ Automatic deployment triggered for {configuration.name}")
	
	async def _trigger_configuration_deployment(self, configuration: ConfigurationResponse):
		"""Trigger deployment for updated configuration."""
		if not self.gitops_engine:
			return
		
		await self.gitops_engine.create_deployment_request(
			configuration_id=configuration.id,
			target_environment="staging",
			deployment_config={
				'auto_rollback': True,
				'validation_required': True
			}
		)
	
	async def _generate_configuration_insights(self, configuration: ConfigurationResponse):
		"""Generate AI insights for new configuration."""
		if not self.ai_engine:
			return
		
		try:
			recommendations = await self.ai_engine.generate_recommendations(configuration.value)
			
			for rec in recommendations:
				if rec.get('confidence', 0) > 0.7:
					insight = IntelligentInsight(
						insight_id=f"config_insight_{configuration.id}_{int(datetime.now().timestamp())}",
						insight_type="configuration_optimization",
						title=rec.get('title', 'Configuration Optimization'),
						description=rec.get('description', ''),
						confidence=rec.get('confidence', 0.0),
						priority='high' if rec.get('confidence', 0) > 0.8 else 'medium',
						actionable=True,
						recommendations=[rec.get('recommendation', '')],
						evidence={
							'configuration_id': configuration.id,
							'configuration_name': configuration.name,
							'recommendation_type': rec.get('type', 'optimization')
						},
						generated_at=datetime.now(timezone.utc)
					)
					
					self.intelligence_insights.append(insight)
		
		except Exception as e:
			print(f"‚ö†Ô∏è Error generating configuration insights: {e}")
	
	async def _generate_update_insights(
		self,
		updated_config: ConfigurationResponse,
		previous_config: Dict[str, Any]
	):
		"""Generate insights about configuration updates."""
		# Compare configurations and generate insights about changes
		insight = IntelligentInsight(
			insight_id=f"update_insight_{updated_config.id}_{int(datetime.now().timestamp())}",
			insight_type="configuration_change",
			title=f"Configuration Updated: {updated_config.name}",
			description=f"Configuration {updated_config.name} was updated successfully",
			confidence=0.9,
			priority="medium",
			actionable=False,
			recommendations=[
				"Monitor performance impact of changes",
				"Validate in staging environment before production deployment"
			],
			evidence={
				'configuration_id': updated_config.id,
				'previous_version': previous_config.get('version', 'unknown'),
				'new_version': updated_config.version,
				'change_timestamp': datetime.now(timezone.utc).isoformat()
			},
			generated_at=datetime.now(timezone.utc)
		)
		
		self.intelligence_insights.append(insight)
	
	async def _record_performance_prediction(
		self,
		configuration_id: str,
		prediction: ModelPrediction
	):
		"""Record performance prediction for later validation."""
		if self.analytics_engine:
			await self.analytics_engine.record_metric(
				metric_type=AnalyticsMetricType.PERFORMANCE,
				name="predicted_response_time",
				value=float(prediction.prediction),
				tags={
					'configuration_id': configuration_id,
					'model_version': prediction.model_version,
					'confidence': str(prediction.confidence.value)
				},
				metadata={
					'prediction_timestamp': prediction.prediction_timestamp.isoformat(),
					'features_used': prediction.features_used
				}
			)
	
	# ==================== Public Interface ====================
	
	async def get_system_status(self) -> Dict[str, Any]:
		"""Get comprehensive system status."""
		status = {
			'service_status': 'healthy',
			'components': {
				'core_service': self.core_service is not None,
				'ai_engine': self.ai_engine is not None,
				'ml_engine': self.ml_engine is not None,
				'analytics_engine': self.analytics_engine is not None,
				'security_engine': self.security_engine is not None,
				'automation_engine': self.automation_engine is not None,
				'gitops_engine': self.gitops_engine is not None
			},
			'intelligence_insights': len(self.intelligence_insights),
			'autonomous_actions': len(self.autonomous_actions),
			'last_health_check': self.last_health_check.isoformat() if self.last_health_check else None
		}
		
		# Add automation status if available
		if self.automation_engine:
			automation_status = await self.automation_engine.get_automation_status()
			status['automation'] = automation_status
		
		return status
	
	async def close(self):
		"""Clean up all service components."""
		print("üîÑ Shutting down Enhanced Central Configuration Service...")
		
		if self.core_service:
			await self.core_service.close()
		
		if self.ai_engine:
			await self.ai_engine.close()
		
		if self.ml_engine:
			await self.ml_engine.close()
		
		if self.analytics_engine:
			await self.analytics_engine.close()
		
		if self.security_engine:
			await self.security_engine.close()
		
		if self.automation_engine:
			await self.automation_engine.close()
		
		if self.gitops_engine:
			await self.gitops_engine.close()
		
		print("‚úÖ Enhanced service shutdown complete")


# ==================== Factory Functions ====================

async def create_enhanced_configuration_service(
	database_url: str,
	redis_url: str,
	tenant_id: str,
	user_id: str,
	gitops_repository_url: Optional[str] = None,
	models_directory: str = "./ml_models"
) -> EnhancedCentralConfigurationService:
	"""Create and initialize enhanced configuration service."""
	service = EnhancedCentralConfigurationService(
		database_url=database_url,
		redis_url=redis_url,
		tenant_id=tenant_id,
		user_id=user_id,
		gitops_repository_url=gitops_repository_url,
		models_directory=models_directory
	)
	
	# Allow initialization to complete
	await asyncio.sleep(2)
	
	print("üöÄ Enhanced Central Configuration Service ready")
	return service